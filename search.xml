<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – 747]]></title>
    <url>%2F2018%2F02%2F23%2F747%2F</url>
    <content type="text"><![CDATA[747. Largest Number At Least Twice of Others 给定一个数组 nums，这数组里面始终会有且仅有一个最大的数。我们要做的是确定这个最大的数是否比数组里的任意其他数都要大至少两倍。如果是的话，我们返回这个最大的数在数组里的索引，如果不是的话，返回 -1。 示例1：1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. 示例2：123Input: nums = [1, 2, 3, 4]Output: -1Explanation: 4 isn&apos;t at least as big as twice the value of 3, so we return -1. 这个题目很显然不难，但是有一些需要注意的地方。首先是要理清楚如何遍历数组找出最大的数以及第二大的数（如果比第二大的数大至少两倍，就一定满足题目要求），然后是这个题目其实有比较多 edge case，我也是提交了几次才过，如果能在一开始就想清楚 edge case 就比较好。 12345678910111213141516171819202122class Solution(object): def dominantIndex(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 1: return 0 max_num = -1 sec_max_num = -1 max_index = 0 for i, num in enumerate(nums): if num &gt; max_num: sec_max_num = max_num max_num = num max_index = i elif num &gt; sec_max_num: sec_max_num = num if max_num &gt;= sec_max_num * 2: return max_index else: return -1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – 696]]></title>
    <url>%2F2018%2F02%2F22%2F696%2F</url>
    <content type="text"><![CDATA[696. Count Binary Substrings 给定一个字符串 s，数出拥有同样多个数连续的 0 或 1 的非空子字符串数目。符合要求的子字符串还有一个特征，就是它的 0 或 1 必须是连在一起的。也就是说 0011 或 1100 是符合要求的字符串，但是 0101 就不是。相同的子字符串如果出现多次，那我们要把出现的所有次数都算上。 示例 1：1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. 示例 2：123Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&apos;s and 0&apos;s. 示例中的解释基本跟我上面说的一样。 另外有两个提示： s.length 会在 1 和 50,000 之间。 s 只会包含 “0” 或 “1” 这两个字符。 第一个想法是这题应该可以把时间复杂度控制在 O(n)，n 就是 s.length。一开始看起来比较困难的似乎是类似于 “000111” 这种比较长的符合条件的字符串包含了不止一个符合条件的子字符串。仔细想一下其实刚才那个包含 3 个相同 “0” 和 “1” 的字符串就包含了 3 个符合要求的字符串，分别是 “000111”，”0011” 以及 “01”。这样一来就很好处理了，我们只需要遍历字符串，在过程中找出那些最长的符合要求的子字符串，再根据这个子字符串里面有多少个 0（或 1）来确定小的符合条件的子字符串。那么如何找符合要求的最长的子字符串呢，似乎用代码来解释比较好。以 00110011 来举例，我们一开始取第一个字符 ‘0’ 为当前字符，记成 curChar，遍历的时候看每个字符是否和当前字符相同，如果相同，我们记录当前碰到相同字符的次数，curLen。如果不同，比如说碰到第一个 ‘1’ 的时候，就把 curChar 设成 ‘1’，因为我们当前的字符已经不是 ‘0’ 了，所以把 curLen 的值记录到 prevLen 里面，然后 curLen 是现在碰到 ‘1’ 的次数，也就1。再次碰到和 ‘1’ 不一样的字符的时候，证明我们已经找到了一个符合要求的最长子字符串。要记录次数。 解释有点复杂，看代码会清楚一点。 123456789101112131415161718192021222324object Solution &#123; def countBinarySubstrings(s: String): Int = &#123; var prevLen = 0 var curLen = 0 var curChar = s(0) var totalCounts = 0 for (c &lt;- s) &#123; if (c == curChar) &#123; // 字符没有转换 curLen += 1 &#125; else &#123; // 字符转换了 // 如果已经转换过一次，那么 prevLen 就不再是 0 了。 if(prevLen &gt; 0) &#123; // 这时候我们要记录这个最大子字符串包含的所有满足要求子字符串 totalCounts += math.min(prevLen, curLen) &#125; prevLen = curLen curLen = 1 curChar = c &#125; &#125; // 这里要再加一次是因为我们的 for 循环没法记录最后的那个子字符串 totalCounts + math.min(prevLen, curLen) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 775]]></title>
    <url>%2F2018%2F02%2F18%2F775%2F</url>
    <content type="text"><![CDATA[775. Global and Local Inversions 我们有有一个数组 A, A 是 [0, 1, ..., N - 1] 这样一个数组的任意排列。A 的长度是 N。就是说 A 是一个所有从 0 到 N - 1 这 N 个数字的任意排列之后组成的一个数组。然后先给两个定义： 当任意 i 和 j 满足 0 &lt;= i &lt; j &lt; N 以及 A[i] &gt; A[j] 时，我们称其为一个全局倒置（Global Inversions）。 当任意的 i 满足 0 &lt;= i &lt; N 以及 A[i] &gt; A[i+1] 时，我们称其为一个本地倒置 （Local Inversions）。我们的函数需要判断 A 是否拥有相同数量的全局倒置以及本地倒置，如果是，返回 true。 示例1：123Input: A = [1,0,2]Output: trueExplanation: There is 1 global inversion, and 1 local inversion. 示例2：123Input: A = [1,2,0]Output: falseExplanation: There are 2 global inversions, and 1 local inversion. 题中有额外的三个注意事项： A 是 [0, 1, ..., A.length - 1] 这样一个数组的任意排列。 A 的长度在 [1, 5000] 之间。 这道题的运行时间限制被缩短了。 首先理解一下题目里所谓的全局倒置以及本地倒置。假设 [0, 1, ..., N - 1] 这个数组是最原始的正确排列，因为这个数组里面所有后面的数都比前面的大，那么在其他的可能的排列里面，只要有一个后面的数比前面的小，就是一个全局倒置。本地倒置的话是对于相邻的两个数来说，只要后面的数比前面的小，就是本地倒置。因此不难发现其实本地倒置也是一个全局倒置，所以我们只需要判断是否这个 A 里面所有的倒置都是本地倒置即可。或者说只要有一个不是本地倒置的全局倒置，那我们就返回 false。 根据刚才的分析很容易想到朴素的解法，就是对于每一个数组里的数来说，我看一下它后面不是相邻的位置上有没有比它小的数，如果有，就是 false。很明显时间复杂度接近 1 到 N - 1 的所有数字之和，也就是 O(n^2)。虽然时间复杂度很高很有可能不满足这个题目的要求，但是我们可以当做函数式编程的练习来实现这个解法。 123456789101112131415object Solution &#123; def isIdealPermutation(A: Array[Int]): Boolean = &#123; // 因为对于每个数来说，我想要跟它后面所有除了相邻之外的数字比较，因此我想得到当前数的索引。 // 由于函数式的遍历方法比如 map, foreach 或者我们下面用的 exists 都是不带索引的，因此我们用 zipWithIndex 先将索引加上。 // 对于 A 的每一个元素，zipWithIndex 会返回一个 tuple：（element, indexOfElement） !A.zipWithIndex.exists(cur =&gt; &#123; val curVal = cur._1 // tuple 里的第一个对象，就是原始的 A 里面的值 val curInx = cur._2 // tuple 的第二个对象，当前的索引 // 丢掉当前元素以及和它相邻的那个之后，判断后面的树是否存在比当前元素小的 // 只要存在这样的情况，我们就返回 true，同样上面一层的 exists 也会返回 true // 如果这里的结果是 true，那么很明显最终的结果是 false A.drop(curInx + 2).exists(_ &lt; curVal) &#125;) &#125;&#125; 函数式的写法看起来虽然很酷炫，但是 zipWithIndex 似乎也没有比传统的 for index 的循环优雅很多。看了下 drop 方法的实现之后，发现时间复杂度还得更高一些，因为它需要遍历 curInx + 2 次之后才返回新的数组。运行之后果然是显示超时。那就要想一下其他的更优解法了。 因为这是一个比较特殊的数组，我们可以考虑一下这个数组的特性，假设我们只有 3 个数，首先对于每一个数来说，如果它就处在自己索引所在的位置，那么肯定是没有问题的，这时候数组就是 [0, 1, 2]。如果第一个数是 2，那么不管怎么样第三个数一定小于第一个数，因此不符合要求。所以第一个数只能是 0 或 1。其实根据这里的分析已经可以推导出对于 A 中的每一个数来说，想要符合条件，最多只能在原来的位置上向左或向右偏离一个位置，原来的位置就是这个数字本身作为索引所在的位置。因为偏移两个位置之后一定会产生一个全局倒置。 那么其实解法已经呼之欲出了：1234567// not accepted python. Time limit exceeded.object Solution &#123; def isIdealPermutation(A: Array[Int]): Boolean = &#123; // 计算每个值和当前索引的偏移量，如果大于一，就返回 false。 !(A.zipWithIndex.exists(el =&gt; math.abs(el._1 - el._2) &gt; 1)) &#125;&#125; 但是上面的解法也超时了，去看了下 zipWithIndex 的实现之后发现这个函数也会遍历一遍 A，为它的每一个元素加上索引。所以这次遍历导致了额外的运行时间，虽然从时间复杂度上来讲， O(2n) 和 O(n) 其实没什么差别。但是显然这个题目的提醒里给到的信息还是有用的，它的判断条件对时间十分敏感。那我们就不能用那么函数式的写法来写了，这个时候用 Java 来写的话一个传统的 For 循环就很快解决了。那我们用 python 来实现的话，可以是这样：123456object Solution &#123; def isIdealPermutation(A: Array[Int]): Boolean = &#123; // 先构造一个索引列表，从 0 到 A.size - 1 !(Range(0, A.size).exists(index =&gt; math.abs(A(index) - index) &gt; 1)) &#125;&#125; 这一次终于过了，但是真要考虑细节的话，其实这样写会比用 Java For 循环多用了 O(n) 的空间复杂度（Range 生成的索引列表）。当然我们也可以用一个 index 变量和 While 循环来完全模仿 Java For 循环的写法，那就可以避免这个额外空间复杂度了，但是毕竟 one-liner (一行解决的代码) 的诱惑很大🙈。这题时间复杂度和空间复杂度都是 O(n)，而且是严格的 O(n), 时间上面如果是 O(2n) 都会导致超时。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 687]]></title>
    <url>%2F2018%2F02%2F10%2F687%2F</url>
    <content type="text"><![CDATA[687. Longest Univalue Path 题目大意是给出一个二叉树，我们要找出最长的一条路径，该路径中所有节点的值都相同，并返回该路径的长度（所谓的“最长相同值路径”的长度）。两个节点之间的长度指的是节点之间边的数量这个题目的关键是理解这个“最长相同值路径”。题目中没有给出这个名词详细的解释，只给了两个例子，我们先看例子。 示例1：Input:12345 5 / \ 4 5 / \ \1 1 5 Output:2 Input:12345 1 / \ 4 5 / \ \4 4 5 Output:2 第一个例子可以看到根节点和右子树组成的3个5拥有最长相同值路径，第一个 5 和最后一个 5 之间一共有 2 条边，所以是 2。第二个例子左边的 3 个 4 构成了最长相同值路径，这条路径从最左下角的4开始，经过父节点的那个 4，到达右边的 4，所以长度也是 2。 这个最长相同值路径看起来似乎很容易定义，但是我在一开始做这道题的时候没想清楚这个概念的确切含义就开始写代码，导致走了很多弯路。所以我们先来分析一下这个概念的具体含义。这个概念有以下特性： 这个路径不是无限分叉的，不然就构不成一条从头到尾的路径。 但是这个路径允许有至多一个分叉点，例二里面的父节点 4 就是一个例子。当然也可以没有分叉点，比如例 1。 这个概念导致路径中的分叉点成了一个特殊的点，因此我们可以从这里做文章。 在不考虑细节和具体实现的的情况下，我的一个单纯的想法是遍历节点，每次遍历的时候找到以这个节点为分叉节点的相同值路径长度。基于这个想法，我们可以用一个全局变量记录这个最大值，然后每次遍历的时候比较改变这个最大值。但是这个方法并不函数式，因此我们使用递归的方式来实现:123456789101112def longestUnivaluePath(root: TreeNode): Int = &#123; if (root == null) &#123; 0 &#125; else &#123; // 假设 findLength 会找到以某个节点为分叉节点的最长相同值路径 val nodeLen = findLength(root) // 以当前节点为分叉节点的最长相同值路径 val leftLen = longestUnivaluePath(root.left) // 左子树的最长路径 val rightLen = longestUnivaluePath(root.right) // 右子树的最长路径 // 返回上面三个值中最大的那个 (nodeLen :: leftLen :: rightLen :: Nil) reduce (_ max _) // 构造一个 list 并返回最大值 &#125;&#125; 所以我们现在只要把 findLength 这个方法实现就可以了。这里是我纠结最久的地方，重写了几次，原因就是之前说的没有把最长相同值路径的定义想清楚就开始写了。我们再回顾一下上面讲到的两个特性，根据那两个特性，我们可以总结出 findLength 方法该怎么写： 对于可能存在的分叉点而言，我们要做的就是找到它左子树和右子树的最大相同值路径长度，返回相加的值。 对于不是分叉点的节点，我们不能把它的左子树和右子树的最大相同路径长度相加，而是要对比两个值，返回大的那个。所以完整的代码如下：123456789101112131415161718192021222324252627282930object Solution &#123; def longestUnivaluePath(root: TreeNode): Int = &#123; if (root == null) &#123; 0 &#125; else &#123; // 假设 findLength 会找到以某个节点为分叉节点的最长相同值路径长度 val nodeLen = findLength(root) // 以当前节点为分叉节点的最长相同值路径长度 val leftLen = longestUnivaluePath(root.left) // 左子树的最长路径 val rightLen = longestUnivaluePath(root.right) // 右子树的最长路径 // 返回上面三个值中最大的那个 (nodeLen :: leftLen :: rightLen :: Nil) reduce (_ max _) // 构造一个 list 并返回最大值 &#125; &#125; def findLength(node: TreeNode): Int = &#123; // 对分叉节点来说，找到左右子树的最长相同值路径长度，并返回和 findChildLength(node.left, node.value) + findChildLength(node.right, node.value) &#125; def findChildLength(child: TreeNode, rootValue: Int): Int = &#123; // 对于非分叉节点来说，如果值不等于分叉节点的值，则返回0 if (child == null || child.value != rootValue) &#123; 0 &#125; else &#123; val left = findChildLength(child.left, rootValue) val right = findChildLength(child.right, rootValue) // 首先这个节点跟分叉节点值相同，因此返回的最小值是 1 // 然后再加上左右子树中比较大的那个相同值路径长度 1 + (left max right) &#125; &#125;&#125; 时间复杂度方面，对于 longestUnivaluePath 这个方法来说，这是一个先序遍历，所以它的时间复杂度是 O(n)，但是对于每一个节点，我们又做了 findLength 这个操作，这个操作理论上最坏情况也会对从当前节点开始的所有子节点做遍历。但是总的复杂度绝对不是 O($n^2$)，因为对于每个子节点来说，它所需要遍历的节点数目是成倍下降的，因此最大的时间复杂度应该是 O($n\log n$)，精确的值应该比这个更小一点，但是不知道该怎么求，欢迎留言讨论。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode - Leetcode 653]]></title>
    <url>%2F2018%2F01%2F07%2F653%2F</url>
    <content type="text"><![CDATA[653. Two Sum IV - Input is a BST 题目大意是说我们有一颗二叉搜索树 （BST），判断树里是否有任意两个数的和等于给定的数 K，如果有的话返回 true。样例 1：12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True 样例 2：12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False 最单纯的想法是使用一个集合保存树的节点值，遍历这棵树，每碰到一个节点 x，就看一下这个集合里是否存在和 x 相加成为目标值 k 的那个值，具体地就是查看集合是否存在 k - x 这个值。这个想法还是比较好实现的： 1234567891011121314151617181920212223/** * Definition for a binary tree node. * class TreeNode(var _value: Int) &#123; * var value: Int = _value * var left: TreeNode = null * var right: TreeNode = null * &#125; */import python.collection.mutable.Set // 注意这里我们用 mutable setobject Solution &#123; def findTarget(root: TreeNode, k: Int): Boolean = &#123; var cache = Set[Int]() findTarget(root, cache, k) &#125; private def findTarget(t: TreeNode, cache: Set[Int], k: Int): Boolean = &#123; if (t == null) return false if (cache.contains(t.value)) return true // 存放 cache 的时候可以把 k - t.value 存进去 // 或者也存 t.value, 在上面那一步去查看 cache.contains(k - t.value) cache.add(k - t.value) findTarget(t.left, cache, k) || findTarget(t.right, cache, k) &#125;&#125; 上门的解法最差情况遍历了树的所有节点，然后对于每个节点都有可能会占用额外的存储空间。因此时间和空间复杂度都是 O(n)。后来网上看到另一个思路。由于是二叉搜索树，因此对它的中序遍历结果是个有序的递增数列。我们就可以把这个问题转变成一个数组的 2-sum 问题。如果是放在数组上而不是树上来解这个问题，虽然也可以使用同样的思路用一个集合来做，但是这样浪费了额外的空间（前提是这个题目本来说是在数组上而不是树上）。我们可以用一个比较巧妙的双指针方法来解。一开始 l 指针指向数组的开头，r 指针指向数组的结尾。考察 l 和 r 代表的值的和，因为数组是有序的，因此如果这个和比 k 小，我们只需要右移 l 指针，反之左移 r 指针。12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * class TreeNode(var _value: Int) &#123; * var value: Int = _value * var left: TreeNode = null * var right: TreeNode = null * &#125; */import python.collection.mutable.ArrayBufferobject Solution &#123; def findTarget(root: TreeNode, k: Int): Boolean = &#123; var li = ArrayBuffer[Int]() inorder(root, li) var l = 0 var r = li.length - 1 while(l &lt; r) &#123; // 如果 l 和 r 相交还没有找到，那么肯定没有 var total = li(l) + li(r) if (total &lt; k) &#123; l += 1 &#125; else if (total &gt; k) &#123; r -= 1 &#125; else &#123; return true &#125; &#125; false &#125; private def inorder(t: TreeNode, li: ArrayBuffer[Int]): Unit = &#123; if (t == null) return inorder(t.left, li) li += t.value inorder(t.right, li) &#125;&#125; 可以这样写了之后代码长度长了不少，可读性也收到影响，而且最重要的时候因为我们还是需要一个 ArrayBuffer 来存储树的节点，因此空间复杂度并没有降低，还是 O(n)。不过这里我们看似对整个数据进行了不止一遍的遍历，但是整个时间复杂度还是 O(n)，Big O notation 的特点是省略 n 前面的常数，比如 2n，因为这个没有意义。有的代码看起来只有一次遍历，但是遍历中间的逻辑很复杂，做了大量的操作，这样的实际 cpu 时间可能会比两次简单遍历的时间要久。不过按我之前说的，这个思路在本身就是数组或者其他的一些情况下是个很好的节省空间的思路。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 617]]></title>
    <url>%2F2018%2F01%2F04%2F617%2F</url>
    <content type="text"><![CDATA[Leetcode 617. Merge Two Binary Trees 这个题目虽然是简单题，但是感觉还是蛮有意思的。题目大意是我们现在有两颗二叉树，然后我们要把它们合在一起生成一个新的二叉树。假象一下这个过程，因为并没有保证两颗树是相同大小的，所以合的时候，有的节点是重叠的，有的节点是单独的。我们需要把重叠节点的值加在一起，单独节点的值就保持不动。下面看一个例子：1234567891011121314Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 题目中还特意指出需要从树的根节点开始合并。我感觉这句话与其说是个限制还不如说是个提示，我们知道二叉树由于它自身的特性，大部分的操作都可以使用递归的方法来实现。这个题目也不例外。根据从根节点开始的提示，我们可以使用先序遍历（preorder traversal）。下面是我的实现123456789101112131415161718/** * Definition for a binary tree node. * class TreeNode(var _value: Int) &#123; * var value: Int = _value * var left: TreeNode = null * var right: TreeNode = null * &#125; */object Solution &#123; def mergeTrees(t1: TreeNode, t2: TreeNode): TreeNode = &#123; if (t1 == null) return t2 // base case if (t2 == null) return t1 // another base case val root = new TreeNode(t1.value + t2.value) // 从根节点开始 root.left = mergeTrees(t1.left, t2.left) // 分别看根节点的左子树 root.right = mergeTrees(t1.right, t2.right) // 以及右子树 root &#125;&#125; 上面代码中有几个值得注意的地方： 在第一个 base case 中，t1 是 null 的时候如果 t2 也同时是 null，返回 t2 也是正确的，表明我们新的树也在这里成为了叶子节点。 两个 base case，返回的必须是 t2 或者 t1, 而不能是类似 new TreeNode(t1.value) 这样的节点，因为 t1 或者 t2 可能还有子节点。 这个题目的精确时间复杂度似乎有点难求，因为其实我们并没有遍历两棵树的所有节点。假设一个极端的情况，t1 只有左子树，t2 只有右子树，那么其实我们的算法运算一次就结束了。非要精确形容的话，我们假设两棵树重叠节点的数目是 K, 那么我们的时间复杂度是 O(K)。空间复杂度也类似，我们并没有给新树上的每个节点分配内存空间，而是重用了之前树中的节点。所以存储树的空间复杂度是 O(K)。但是由于我们使用了递归，还必须考虑递归每次调用占用的栈的空间。递归调用的次数和两棵树重叠部分的形状有关系，如果是一个一边倒的形状（skewed），那么栈的深度是 K。但是一般来说我们假设树是左右平衡的，那么深度是 $\log_2 K$，最终的空间复杂度是 O($\log_2 K + K$)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 657]]></title>
    <url>%2F2018%2F01%2F04%2F657%2F</url>
    <content type="text"><![CDATA[Leetcode 657. Judge Route Circle 题目大意是有个机器人从（0，0）位置出发，每次会上下左右选一个方向移动 1 步，我们要判断它最终是否回到原点。它的移动轨迹用一个字符串来描述，每个字符表示往一个方向移动了一步，可能的字符以及方向是：L (左)， R (右)， U (上)， D (下)。 示例1：12Input: &quot;UD&quot;Output: true 示例2：12Input: &quot;LL&quot;Output: false 这个题目一开始给我的感觉是很适合用栈，但是再转念一想其实不需要这么麻烦，只要统计上下的次数以及左右的次数是否相同就可以了。本质上的思路是跟使用栈一样的，但是在这个题目里我们只需要使用两个变量来分别记录上和下的次数以及左和右的次数。下面是代码： 123456789101112131415object Solution &#123; def judgeCircle(moves: String): Boolean = &#123; var vertical = 0 // 记录上下方向上的步数 var horizontal = 0 // 记录左右方向上的步数 for (c &lt;- moves) &#123; c match &#123; case 'U' =&gt; horizontal += 1 case 'D' =&gt; horizontal -= 1 case 'L' =&gt; vertical -= 1 case 'R' =&gt; vertical += 1 &#125; &#125; horizontal == 0 &amp;&amp; vertical == 0 &#125;&#125; 这里对于字符串里面的每个字符都进行了处理，所以时间复杂度是 O(N)，空间上面的话因为只用了2个变量，所以是 O(1)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
</search>
