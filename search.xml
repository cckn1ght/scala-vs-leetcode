<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cracking the Coding Interview – "shuffle-deck"]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCITI%2Fshuffle-deck%2F</url>
    <content type="text"><![CDATA[最近拿这个题目面试了好几面试者，很少有能能给出最优解，看来确实还是挺难的一个题目。题目意思很简单，就是假设我们有 52 张牌，实现一个洗牌的方法。其实就是打乱数组的方法，但是要求是必须是完全洗牌，也就是说，数组经过打乱之后每一种排列的可能性必须相等。我们可以使用生成随机数的方法。 我一般会先问面试者如果不考虑时间复杂度，那我们可不可以有什么比较暴力的方法来解这个题。大多数面试者会想到我们每次从 0 到 51 中取一个随机数，取到之后选择这个随机位置上的元素，放到一个新的数组里面，取过的元素进行某种标记（比如用一个 set 来记录取过的元素），之后继续取随机数，如果是取过的，则跳过，再取一次。 这个方法 Python 也好实现：123456789101112131415import randomdef shuffle(deck): """ :type deck: array[int] :rtype: void """ # 记录被随机过的索引 randomed = set() shuffled = [] while len(randomed) &lt; len(deck): k = random.randint(0, len(deck) - 1) if k not in randomed: randomed.add(k) shuffled.append(deck[k]) deck[:] = shuffled[:] 抛开时间复杂度不说，仔细想想这个方法可能并不是完全随机，虽然我没有仔细证明，但是感觉仅仅依靠检查是否这个数已经被使用过不能保证每种可能性完全一样。 那么稍微好一些的方法是随机取到一个元素之后，我们把这个元素从原数组中删除，下次随机的时候只要在小一点的数组上取随机元素就行了。 1234567891011import randomdef shuffle(deck): """ :type deck: array[int] :rtype: void """ temp = deck[:] for i in range(0, len(deck)): k = random.randint(0, len(temp) - 1) deck[i] = temp[k] temp = temp[:k] + temp[k + 1:] 这个方法可以保证我们的数组被完全随机的打乱，但是缺点是我们每次要用 n - i 的时间去重新构造更小的数组，所以总的来说时间复杂度还是 O(n^2) 有个面试者提到如果用链表的话时间复杂度就不需要那么高了，理由是链表在删除元素的时候只用 O(1) 的操作就行了。这个说法确实没有错，但是链表的代价在于每次去取第 k 个元素的时候需要 O(k) 的时间复杂度。所以最终的结果其实并没有区别。 上面的思路再变一下就是随机取出的元素放在新的数组里，这样新的数组越来越大，旧的数组越来越小。但是可以注意到一个特性，新旧数组合在一起的大小是不变的，也就是原数组的大小，那我们能不能不使用新数组来存随机取出来的元素而使用旧数组的尾部呢？应该是可以的。123456789101112import randomdef shuffle(deck): """ :type deck: array[int] :rtype: void """ left = len(deck) - 1 for i in range(len(deck) - 1, -1, -1): k = random.randint(0, left) left -= 1 deck[k], deck[i] = deck[i], deck[k] 其实这个思路最巧妙的地方在于把随机选择到的元素和排在末尾的元素进行了交换位置而不是像之前的方法一样去压缩数组。因此时间复杂度就降到了 O(n)。仔细想一下随机的本质，会发现我们只需要保持下一次随机的范围里是除了上一次随机选择到的数之外的所有数就可以了，并不需要刻意去保持原有数组的顺序。因此可以使用交换元素的方法而不是压缩数组的方法。感觉这个思路和快速排序的思路在某种程度上很像。 最后提供 「Cracking The Coding Interview」上面的思路。假象我们已经有一个完全打乱的数组了，现在要在这个基础上加如一个数，使得数组还是保持完全打乱的状态，我们该怎么做呢？我一开始看到这个提示的时候想到是找一个随机的位置插入就行了，但是插入又是一个费时间的操作，正确的思路是在已有的数组里找一个随机的元素，跟我们的新元素（假设新元素一开始在数组的最后）交换位置就行了。很明显这是一个递归的思路，我们可以递归地写出来。代码如下：123456789101112131415161718import randomdef shuffle(deck): """ :type deck: array[int] :rtype: void """ shuffle_helper(deck, len(deck) - 1)def shuffle_helper(deck, need_shuffle): """ :type deck: array[int] :type need_shuffle: int :rtype: void """ if need_shuffle &gt; 0: shuffle_helper(deck, need_shuffle - 1) k = random.randint(0, need_shuffle) deck[k], deck[need_shuffle] = deck[need_shuffle], deck[k] 但是很明显这个代码十分冗余，而且这个简单的思路没有必要用到递归，我们可以更优雅地实现：12345678910import randomdef shuffle(deck): """ :type deck: array[int] :rtype: void """ for i, card in enumerate(deck): if i &gt; 0: k = random.randint(0, i) deck[i], deck[k] = deck[k], deck[i]]]></content>
      <categories>
        <category>算法</category>
        <category>CITI</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cracking the Coding Interview – "string-array-1-8"]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCTCI%2Fstring-array-1-8%2F</url>
    <content type="text"><![CDATA[Assume you have a method isSubstring which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstring (e.g.,”waterbottle”is a rotation of”erbottlewat”). 假设我们有一个 isSubString 方法，这个方法会检查一个字符串是否是另一个字符串的子字符串。给定两个字符串 s1 和 s2，写一个算法来检测 s2 是否是 s1 的 rotation，要求是只能使用一次之前给我们的 isSubString 方法。（所谓的 rotation 可以这样理解：假想字符串是一个管道，里面的字符是管道里的内容，字符出了管道的右边之后又会回到管道的最左边，经过这样的移动之后新的字符串就是旧的字符串的 rotation。比如 “waterbottle” 是 “erbottlewat” 的一个 rotation。） 我们可以以上面的那个单词 waterbottle 为例来理解这个题目，位移之后的 erbottlewat 可以拆分成 erbottle 和 wat 两个部分，我们不妨假设第一个部分为 x，第二个部分为y。这样的话 erbottlewat 就可以表示成 xy。再看原来的词 waterbottle，它可以拆分成 wat 和 erbottle 这两个部分，也就是 yx。也就是说，不管一个字符串怎么位移，它总可以表示成两个被拆分的部分，而且这两个被拆分的部分的顺序和在原字符串中的顺序相反。那么，如果我们把 xy 这个单词叠加一次变成 xyxy。可以发现原字符串 yx 一定是叠加之后的 xyxy 的子字符串。这时候我们只需要使用一次 isSubString 就可以了。 12345678910def is_rotation(s1, s2): """ :type s1: str :type s2: str :rtype: boolean """ # Check s1 and s2 are eqaul length and not empty if len(s1) &gt; 0 and len(s1) == len(s2): return isSubString(s1, s2 + s2) return False]]></content>
      <categories>
        <category>算法</category>
        <category>CTCI</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cracking the Coding Interview – "string-array-1-1"]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCTCI%2Fstring-array-1-1%2F</url>
    <content type="text"><![CDATA[「Cracking the Coding Interview」一直是我比较喜欢的算法书，现在开始写这本书上面的算法。这是 String &amp; Arrays 系列的第一题。 Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?题目要求我们写一个算法来判断是否一个给定的字符串中的所有字符都是独一无二的。更进一步来说，我们能否不使用额外的数据结构来做到这件事情？ 首先，如果我们可以使用其他的数据结构，那么我们可以使用一个 Set 来记录遍历字符串时每个新碰到的字符，如果有的字符已经存在于 Set 中了，那么就返回 False。123456789101112# with Additional Data Structuredef is_unique(s): """ :type s: str :rtype: boolean """ cache = set() for c in s: if c in cache: return False cache.add(c) return True 很显然如果可以用 Set 或者 Map 之类的数据结构，这道题比较容易，但是如果不能用其他的数据结构呢？比较自然的想法是遍历两边字符串，第一次遍历取得每个字符的时候，再遍历一遍这个字符串，查看除了当前字符之外是否还存在其他的字符跟当前字符一样。简化一下之后可以在第二次遍历时只遍历当前位置之后的字符串，因为前面的字符串已经不需要比较了。 12345678910# w/o Adiitional Data Structuredef is_unique(s): """ :type s: str :rtype: boolean """ for i, c in enumerate(s): if c in s[i + 1:]: return False return True Python 语言的特点让我们的第二次遍历可以写的特别优雅。这大概也是大部分人一开始爱上 Python 的理由吧。]]></content>
      <categories>
        <category>算法</category>
        <category>CTCI</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 771]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F771%2F</url>
    <content type="text"><![CDATA[771. Jewels and Stones 我们有两个字符串，J 字符串代表有哪些宝石（Jewels），S 字符串代表我们所有的石头（Stones）。J 中的每个字符代表某一种宝石，并且不会有重复的字符。S 中的每个字符是我们有的一块石头，如果石头的字符跟某块宝石的字符相同，就是一块宝石，我们想知道 S 中一共有多少宝石。字符的大小写是区分的，a 和 A 是两种不同的石头（或宝石）。 示例1：12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 示例2：12Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0 12345678910111213141516171819class Solution: def numJewelsInStones(self, J, S): """ :type J: str :type S: str :rtype: int """ jewels = set() # res 用来记录我们有的珠宝数量 res = 0 # 遍历所有的珠宝，把每个珠宝是什么记录下来，后面好比较 for j in J: jewels.add(j) # 遍历我们有的石头 for s in S: # 检查是否石头是珠宝 if s in jewels: res += 1 return res 这道题很简单，主要考点就是两个，一个是字符串的遍历操作，另一个是集合(Set)这个数据结构在 Python 中的应用。关于数据结构以及集合，我们会在另外的文章里详细解释。时间复杂度是 O(n), 其中 n 是 J 和 S 中更长的那个字符串的长度。空间复杂度是 O(k)，其中 k 是 J 字符串的长度。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 747]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F747%2F</url>
    <content type="text"><![CDATA[747. Largest Number At Least Twice of Others 给定一个数组 nums，这数组里面始终会有且仅有一个最大的数。我们要做的是确定这个最大的数是否比数组里的任意其他数都要大至少两倍。如果是的话，我们返回这个最大的数在数组里的索引，如果不是的话，返回 -1。 示例1：1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. 示例2：123Input: nums = [1, 2, 3, 4]Output: -1Explanation: 4 isn&apos;t at least as big as twice the value of 3, so we return -1. 注意： nums 的长度会在 [1, 50] 之间。 任意一个 nums[i] 会在 [0, 99] 之间。 这个题目很显然不难，但是有一些需要注意的地方。首先是要理清楚如何遍历数组找出最大的数以及第二大的数（如果比第二大的数大至少两倍，就一定满足题目要求）。因为这个题目给了比较多的数据上的限制，比如数组里的任何一个数都大于等于0，而且只需要记录最大以及次大的两个数，所以将题目简化了不少。我们可以使用 max_num 以及 sub_max_num 来分别记录最大及次大。因为任何数都大于等于0，因此这两个数字可以初始化成 -1, 这样就保证了他们比数组中的任何数都小，在后面的逻辑判断中不会出问题。然后找到最新的最大数之和，要记得同步地更新 sub_max_num 为之前的 max_num。细节可以看代码。123456789101112131415161718192021222324252627282930class Solution(object): def dominantIndex(self, nums): """ :type nums: List[int] :rtype: int """ # 初始化最大及次大数 max_num = -1 sub_max_num = -1 # 初始化最大数的索引 max_index = -1 # python 遍历数组小技巧，如果想要遍历的时候也同时得到元素的索引 # 可以在原始数组上使用 enumerate 函数。 # 其中 i 就是 num 对应的索引 for i, num in enumerate(nums): # 找到最大的数了 if num &gt; max_num: # 这里用到了 python 特有的 unpacking 特性。 # 正常的写法是以下的两行： # sub_max_num = max_num # max_num = num max_num, sub_max_num = num, max_num max_index = i # 找到一个次大的数 elif num &gt; sub_max_num: sub_max_num = num if max_num &gt;= sub_max_num * 2: return max_index else: return -1 很显然时间复杂度是 O(n), 空间复杂度是 O(1)。但是这个题目如果延伸一下，记录数组中前 k 个最大的数，就没那么简单了。直接给数组排序当然可以，但是首先排序的最小复杂度是 O($n\log n$)，其次是那种情况下，往往题目会要求记录一个数据流的前 k 个最大的数，也就是不方便给数组完整排序，因为数据是持续地进来的。大家可以先考虑考虑怎么做，有空碰到了类似的题目我们再讨论。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 696]]></title>
    <url>%2Fleetcode%2F696%2F</url>
    <content type="text"><![CDATA[696. Count Binary Substrings 给定一个字符串 s，数出拥有同样多个数连续的 0 或 1 的非空子字符串数目。符合要求的子字符串还有一个特征，就是它的 0 或 1 必须是连在一起的。也就是说 0011 或 1100 是符合要求的字符串，但是 0101 就不是。相同的子字符串如果出现多次，那我们要把出现的所有次数都算上。 示例 1：1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. 示例 2：123Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&apos;s and 0&apos;s. 示例中的解释基本跟我上面说的一样。 另外有两个提示： s.length 会在 1 和 50,000 之间。 s 只会包含 “0” 或 “1” 这两个字符。 第一个想法是这题应该可以把时间复杂度控制在 O(n)，n 就是 s.length。一开始看起来比较困难的似乎是类似于 “000111” 这种比较长的符合条件的字符串包含了不止一个符合条件的子字符串。仔细想一下其实刚才那个包含 3 个相同 “0” 和 “1” 的字符串就包含了 3 个符合要求的字符串，分别是 “000111”，”0011” 以及 “01”。这样一来就很好处理了，我们只需要遍历字符串，在过程中找出那些最长的符合要求的子字符串，再根据这个子字符串里面有多少个 0（或 1）来确定小的符合条件的子字符串。那么如何找符合要求的最长的子字符串呢，似乎用代码来解释比较好。以 00110011 来举例，我们一开始取第一个字符 ‘0’ 为当前字符，记成 cur_char，遍历的时候看每个字符是否和当前字符相同，如果相同，我们记录当前碰到相同字符的次数，cur_len。如果不同，比如说碰到第一个 ‘1’ 的时候，就把 cur_char 设成 ‘1’，因为我们当前的字符已经不是 ‘0’ 了，所以把 cur_len 的值记录到 prev_len 里面，然后 cur_len 是现在碰到 ‘1’ 的次数，也就1。再次碰到和 ‘1’ 不一样的字符的时候，证明我们已经找到了一个符合要求的最长子字符串。要记录次数。 解释有点复杂，看代码会清楚一点。 1234567891011121314151617181920212223242526class Solution: def countBinarySubstrings(self, s): """ :type s: str :rtype: int """ # 这里用了 Python 的一个特性，tuple unpacking prev_len, cur_len = 0, 0 cur_char = s[0] res = 0 for c in s: # 字符没有转换，那我们把 cur_len 增加 if cur_char == c: cur_len += 1 else: # 字符转换了，且已经转换过一次，因为 prev_len 不是 0 # 代表我们已经找到一个符合条件的子字符串 # 这时我们需要统计 res if prev_len &gt; 0: res += min(cur_len, prev_len) # 转换发生的时候，现在的 cur_len 已经变成了 prev_len prev_len = cur_len cur_len = 1 cur_char = c # 最后还要加上这里是因为我们的循环没法处理最后的两个 cur_len 和 prev_len return res + min(cur_len, prev_len) 这个解法只遍历一次，时间复杂度和空间复杂度分别是 O(n) 和 O(1)。]]></content>
      <tags>
        <tag>Easy</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 775]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F775%2F</url>
    <content type="text"><![CDATA[775. Global and Local Inversions 我们有有一个数组 A, A 是 [0, 1, ..., N - 1] 这样一个数组的任意排列。A 的长度是 N。就是说 A 是一个所有从 0 到 N - 1 这 N 个数字的任意排列之后组成的一个数组。然后先给两个定义： 当任意 i 和 j 满足 0 &lt;= i &lt; j &lt; N 以及 A[i] &gt; A[j] 时，我们称其为一个全局倒置（Global Inversions）。 当任意的 i 满足 0 &lt;= i &lt; N 以及 A[i] &gt; A[i+1] 时，我们称其为一个本地倒置 （Local Inversions）。我们的函数需要判断 A 是否拥有相同数量的全局倒置以及本地倒置，如果是，返回 true。 示例1：123Input: A = [1,0,2]Output: trueExplanation: There is 1 global inversion, and 1 local inversion. 示例2：123Input: A = [1,2,0]Output: falseExplanation: There are 2 global inversions, and 1 local inversion. 题中有额外的三个注意事项： A 是 [0, 1, ..., A.length - 1] 这样一个数组的任意排列。 A 的长度在 [1, 5000] 之间。 这道题的运行时间限制被缩短了。 首先理解一下题目里所谓的全局倒置以及本地倒置。假设 [0, 1, ..., N - 1] 这个数组是最原始的正确排列，因为这个数组里面所有后面的数都比前面的大，那么在其他的可能的排列里面，只要有一个后面的数比前面的小，就是一个全局倒置。本地倒置的话是对于相邻的两个数来说，只要后面的数比前面的小，就是本地倒置。因此不难发现其实本地倒置也是一个全局倒置，所以我们只需要判断是否这个 A 里面所有的倒置都是本地倒置即可。或者说只要有一个不是本地倒置的全局倒置，那我们就返回 false。 根据刚才的分析很容易想到朴素的解法，就是对于每一个数组里的数来说，我看一下它后面不是相邻的位置上有没有比它小的数，如果有，就是 false。很明显时间复杂度接近 1 到 N - 1 的所有数字之和，也就是 O(n^2)。虽然时间复杂度很高很有可能不满足这个题目的要求，但是我们可以当做 Python 数组操作的练习来把代码写出来。 12345678910111213class Solution: def isIdealPermutation(self, A): """ :type A: List[int] :rtype: bool """ # 用 enumerate 函数来获得数组元素的索引 i for i, num in enumerate(A): # 数组分割方法 for other_num in A[i + 2:]: if other_num &lt; num: return False return True 运行之后果然是显示超时。那就要想一下其他的更优解法了。 因为这是一个比较特殊的数组，我们可以考虑一下这个数组的特性，假设我们只有 3 个数，首先对于每一个数来说，如果它就处在自己索引所在的位置，那么肯定是没有问题的，这时候数组就是 [0, 1, 2]。如果第一个数是 2，那么不管怎么样第三个数一定小于第一个数，因此不符合要求。所以第一个数只能是 0 或 1。其实根据这里的分析已经可以推导出对于 A 中的每一个数来说，想要符合条件，最多只能在原来的位置上向左或向右偏离一个位置，原来的位置就是这个数字本身作为索引所在的位置。因为偏移两个位置之后一定会产生一个全局倒置。 那么其实解法已经呼之欲出了：12345678910class Solution: def isIdealPermutation(self, A): """ :type A: List[int] :rtype: bool """ for i, num in enumerate(A): if abs(num - i) &gt; 1: return False return True 用 Python 实现居然出奇的简单，这题时间复杂度和空间复杂度是 O(n) 和 O(1)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Medium</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 687]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F687%2F</url>
    <content type="text"><![CDATA[687. Longest Univalue Path 题目大意是给出一个二叉树，我们要找出最长的一条路径，该路径中所有节点的值都相同，并返回该路径的长度（所谓的“最长相同值路径”的长度）。两个节点之间的长度指的是节点之间边的数量这个题目的关键是理解这个“最长相同值路径”。题目中没有给出这个名词详细的解释，只给了两个例子，我们先看例子。 示例1：Input:12345 5 / \ 4 5 / \ \1 1 5 Output:2 Input:12345 1 / \ 4 5 / \ \4 4 5 Output:2 第一个例子可以看到根节点和右子树组成的3个5拥有最长相同值路径，第一个 5 和最后一个 5 之间一共有 2 条边，所以是 2。第二个例子左边的 3 个 4 构成了最长相同值路径，这条路径从最左下角的4开始，经过父节点的那个 4，到达右边的 4，所以长度也是 2。 这虽然是道 Easy 等级的题目，但是它的通过率比很多 Medium 要低的多…. 这个最长相同值路径看起来似乎很容易定义，但是我在一开始做这道题的时候没想清楚这个概念的确切含义就开始写代码，导致走了很多弯路。所以我们先来分析一下这个概念的具体含义。这个概念有以下特性： 这个路径不是无限分叉的，不然就构不成一条从头到尾的路径。 但是这个路径允许有至多一个分叉点（或者说连接两条不同方向的路径的点，我在代码里把它称为 joint），例二里面的父节点 4 就是一个例子。当然也可以没有分叉点，比如例 1。 这个概念导致路径中的分叉点成了一个特殊的点，因此我们可以从这里做文章。 在不考虑细节和具体实现的的情况下，我的一个单纯的想法是遍历节点，每次遍历的时候找到以这个节点为分叉节点的相同值路径长度。基于这个想法，我们可以用一个全局变量记录这个最大值，然后每次遍历的时候比较改变这个最大值。但是换个角度想，我们可以让递归遍历的方法直接返回最大值，这么想来用递归似乎更简单一点，而且可以避免全局变量就应该尽量避免： 1234567891011121314def longestUnivaluePath(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 # 找到以当前节点为分叉点的路径长度 nodeLen = self.find_length_of_joint(root) # 递归地去找当前节点的左子树及右子树 leftLen = self.longestUnivaluePath(root.left) rightLen = self.longestUnivaluePath(root.right) # 返回最大的那个 return max(nodeLen, leftLen, rightLen) 所以我们现在只要把 find_length_of_joint 这个方法实现就可以了。这里是我纠结最久的地方，重写了几次，原因就是之前说的没有把最长相同值路径的定义想清楚就开始写了。我们再回顾一下上面讲到的两个特性，根据那两个特性，我们可以总结出 find_length_of_joint 方法该怎么写： 对于可能存在的分叉点而言，我们要做的就是找到它左子树和右子树的最大相同值路径长度，返回相加的值。 对于不是分叉点的节点，我们不能把它的左子树和右子树的最大相同路径长度相加，而是要对比两个值，返回大的那个。所以完整的代码如下：123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def longestUnivaluePath(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 # 找到以当前节点为分叉点的路径长度 nodeLen = self.find_length_of_joint(root) # 递归地去找当前节点的左子树及右子树 leftLen = self.longestUnivaluePath(root.left) rightLen = self.longestUnivaluePath(root.right) # 返回最大的那个 return max(nodeLen, leftLen, rightLen) def find_length_of_joint(self, node): return self.find_length(node.left, node.val) + \ self.find_length(node.right, node.val) def find_length(self, node, joint_value): if not node or node.val != joint_value: return 0 return 1 + max(self.find_length(node.left, joint_value), self.find_length(node.right, joint_value)) 这里顺便提一下 Python 里面很长的行应该怎么分行。一种方法是使用 \（backslash），如果有操作符的话，比较推荐的方式是在操作符之后使用反斜杠，如代码中的 24 行。还有一种方式是利用 Python 自带的特性，在 ()、[] 和 {} 内换行，如 29 行。换行之后的缩进似乎不是很强制，我喜欢把它缩到跟上一行同样语义的地方。 引用下 PEP8： The preferred way of wrapping long lines is by using Python’s implied line continuation inside parentheses, brackets and braces. If necessary, you can add an extra pair of parentheses around an expression, but sometimes using a backslash looks better. Make sure to indent the continued line appropriately. The preferred place to break around a binary operator is after the operator, not before it. 时间复杂度方面，对于 longestUnivaluePath 这个方法来说，这是一个先序遍历，所以它的时间复杂度是 O(n)，但是对于每一个节点，我们又做了 find_length_of_joint 这个操作，这个操作理论上最坏情况也会对从当前节点开始的所有子节点做遍历。但是总的复杂度绝对不是 O($n^2$)，因为对于每个子节点来说，它所需要遍历的节点数目是成倍下降的，因此最大的时间复杂度应该是 O($n\log n$)，精确的值应该比这个更小一点，但是不知道该怎么求，欢迎留言讨论。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>Tree</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode - Leetcode 653]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F653%2F</url>
    <content type="text"><![CDATA[653. Two Sum IV - Input is a BST 题目大意是说我们有一颗二叉搜索树 （BST），判断树里是否有任意两个数的和等于给定的数 K，如果有的话返回 true。样例 1：12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True 样例 2：12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False 最单纯的想法是使用一个集合保存树的节点值，遍历这棵树，每碰到一个节点 x，就看一下这个集合里是否存在和 x 相加成为目标值 k 的那个值，具体地就是查看集合是否存在 k - x 这个值。这个想法还是比较好实现的： 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ cache = set() return self.findHelder(cache, root, k) def findHelder(self, cache, root, k): # base case if not root: return False # 找到了我们的值 if (k - root.val) in cache: return True cache.add(root.val) return self.findHelder(cache, root.left, k) or self.findHelder(cache, root.right, k) 上门的解法最差情况遍历了树的所有节点，然后对于每个节点都有可能会占用额外的存储空间。因此时间和空间复杂度都是 O(n)。后来网上看到另一个思路。由于是二叉搜索树，因此对它的中序遍历结果是个有序的递增数列。我们就可以把这个问题转变成一个数组的 2-sum 问题。如果是放在数组上而不是树上来解这个问题，虽然也可以使用同样的思路用一个集合来做，但是这样浪费了额外的空间（前提是这个题目本来说是在数组上而不是树上）。我们可以用一个比较巧妙的双指针方法来解。一开始 l 指针指向数组的开头，r 指针指向数组的结尾。考察 l 和 r 代表的值的和，因为数组是有序的，因此如果这个和比 k 小，我们只需要右移 l 指针，反之左移 r 指针。1234567891011121314151617181920212223242526272829303132333435363738# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ li = [] # 中序遍历二叉搜索树，得到递增数列 li self.in_order(root, li) # l 从 0 开始，r 从最后开始 l = 0 r = len(li) - 1 # 如果 l == r, 证明数组所有数字已经处理完 while(l &lt; r): cur_sum = li[l] + li[r] if cur_sum &lt; k: l += 1 elif cur_sum &gt; k: r -= 1 else: return True # 如果在 while 循环里没有 return True，表明没有找到 return False # 中序遍历，对 node 的操作在遍历左节点之后。 def in_order(self, node, li): if not node: return self.in_order(node.left, li) li.append(node.val) self.in_order(node.right, li) 可以这样写了之后代码长度长了不少，可读性也收到影响，而且最重要的时候因为我们还是需要一个 ArrayBuffer 来存储树的节点，因此空间复杂度并没有降低，还是 O(n)。不过这里我们看似对整个数据进行了不止一遍的遍历，但是整个时间复杂度还是 O(n)，Big O notation 的特点是省略 n 前面的常数，比如 2n，因为这个没有意义。有的代码看起来只有一次遍历，但是遍历中间的逻辑很复杂，做了大量的操作，这样的实际 cpu 时间可能会比两次简单遍历的时间要久。不过按我之前说的，这个思路在本身就是数组或者其他的一些情况下是个很好的节省空间的思路。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 617]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F617%2F</url>
    <content type="text"><![CDATA[Leetcode 617. Merge Two Binary Trees 这个题目虽然是简单题，但是感觉还是蛮有意思的。题目大意是我们现在有两颗二叉树，然后我们要把它们合在一起生成一个新的二叉树。假象一下这个过程，因为并没有保证两颗树是相同大小的，所以合的时候，有的节点是重叠的，有的节点是单独的。我们需要把重叠节点的值加在一起，单独节点的值就保持不动。下面看一个例子：1234567891011121314Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 题目中还特意指出需要从树的根节点开始合并。我感觉这句话与其说是个限制还不如说是个提示，我们知道二叉树由于它自身的特性，大部分的操作都可以使用递归的方法来实现。这个题目也不例外。根据从根节点开始的提示，我们可以使用先序遍历（preorder traversal）。下面是我的实现123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def mergeTrees(self, t1, t2): """ :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode """ # 两个 base case if not t1: return t2 if not t2: return t1 merged = TreeNode(t1.val + t2.val) # 递归地计算左子树以及右子树 merged.left = self.mergeTrees(t1.left, t2.left) merged.right = self.mergeTrees(t1.right, t2.right) return merged 上面代码中有几个值得注意的地方： 在第一个 base case 中，t1 是 None 的时候如果 t2 也同时是 None 的话，返回 t2 也是正确的，表明我们新的树也在这里成为了叶子节点。 两个 base case，返回的必须是 t2 或者 t1, 而不能是类似 TreeNode(t1.val) 这样的节点，因为 t1 或者 t2 可能还有子节点。 这个题目的精确时间复杂度似乎有点难求，因为其实我们并没有遍历两棵树的所有节点。假设一个极端的情况，t1 只有左子树，t2 只有右子树，那么其实我们的算法运算一次就结束了。非要精确形容的话，我们假设两棵树重叠节点的数目是 K, 那么我们的时间复杂度是 O(K)。空间复杂度也类似，我们并没有给新树上的每个节点分配内存空间，而是重用了之前树中的节点。所以存储树的空间复杂度是 O(K)。但是由于我们使用了递归，还必须考虑递归每次调用占用的栈的空间。递归调用的次数和两棵树重叠部分的形状有关系，如果是一个一边倒的形状（skewed），那么栈的深度是 K。但是一般来说我们假设树是左右平衡的，那么深度是 $\log_2 K$，最终的空间复杂度是 O($\log_2 K + K$)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 657]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F657%2F</url>
    <content type="text"><![CDATA[Leetcode 657. Judge Route Circle 题目大意是有个机器人从（0，0）位置出发，每次会上下左右选一个方向移动 1 步，我们要判断它最终是否回到原点。它的移动轨迹用一个字符串来描述，每个字符表示往一个方向移动了一步，可能的字符以及方向是：L (左)， R (右)， U (上)， D (下)。 示例1：12Input: &quot;UD&quot;Output: true 示例2：12Input: &quot;LL&quot;Output: false 这个题目比较简单，可以用来当练手和掌握 Python 的字符串遍历方法。只要统计上下的次数以及左右的次数是否相同就可以了。我们使用两个变量 vertical 和 horizontal 来分别统计上下和左右的次数。上和下分别对 vertical 进行加一和减一，左右也类似，最后只要看这两个变量是否都是 0 就行了。下面是代码： 12345678910111213141516171819class Solution: def judgeCircle(self, moves): """ :type moves: str :rtype: bool """ vertical = 0 horizontal = 0 # 遍历字符串，得到每个字符 c for c in moves: if c == 'U': vertical += 1 elif c == 'D': vertical -= 1 elif c == 'L': horizontal -= 1 elif c == 'R': horizontal += 1 return vertical == 0 and horizontal == 0 这里对于字符串里面的每个字符都进行了处理，所以时间复杂度是 O(N)，空间上面的话因为只用了2个变量，所以是 O(1)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>String</tag>
      </tags>
  </entry>
</search>
