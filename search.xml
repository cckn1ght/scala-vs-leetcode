<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python å¤§æˆ˜ Leetcode â€“ 747]]></title>
    <url>%2F2018%2F02%2F23%2F747%2F</url>
    <content type="text"><![CDATA[747. Largest Number At Least Twice of Others ç»™å®šä¸€ä¸ªæ•°ç»„ numsï¼Œè¿™æ•°ç»„é‡Œé¢å§‹ç»ˆä¼šæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæœ€å¤§çš„æ•°ã€‚æˆ‘ä»¬è¦åšçš„æ˜¯ç¡®å®šè¿™ä¸ªæœ€å¤§çš„æ•°æ˜¯å¦æ¯”æ•°ç»„é‡Œçš„ä»»æ„å…¶ä»–æ•°éƒ½è¦å¤§è‡³å°‘ä¸¤å€ã€‚å¦‚æžœæ˜¯çš„è¯ï¼Œæˆ‘ä»¬è¿”å›žè¿™ä¸ªæœ€å¤§çš„æ•°åœ¨æ•°ç»„é‡Œçš„ç´¢å¼•ï¼Œå¦‚æžœä¸æ˜¯çš„è¯ï¼Œè¿”å›ž -1ã€‚ ç¤ºä¾‹1ï¼š1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. ç¤ºä¾‹2ï¼š123Input: nums = [1, 2, 3, 4]Output: -1Explanation: 4 isn&apos;t at least as big as twice the value of 3, so we return -1. è¿™ä¸ªé¢˜ç›®å¾ˆæ˜¾ç„¶ä¸éš¾ï¼Œä½†æ˜¯æœ‰ä¸€äº›éœ€è¦æ³¨æ„çš„åœ°æ–¹ã€‚é¦–å…ˆæ˜¯è¦ç†æ¸…æ¥šå¦‚ä½•éåŽ†æ•°ç»„æ‰¾å‡ºæœ€å¤§çš„æ•°ä»¥åŠç¬¬äºŒå¤§çš„æ•°ï¼ˆå¦‚æžœæ¯”ç¬¬äºŒå¤§çš„æ•°å¤§è‡³å°‘ä¸¤å€ï¼Œå°±ä¸€å®šæ»¡è¶³é¢˜ç›®è¦æ±‚ï¼‰ï¼Œç„¶åŽæ˜¯è¿™ä¸ªé¢˜ç›®å…¶å®žæœ‰æ¯”è¾ƒå¤š edge caseï¼Œæˆ‘ä¹Ÿæ˜¯æäº¤äº†å‡ æ¬¡æ‰è¿‡ï¼Œå¦‚æžœèƒ½åœ¨ä¸€å¼€å§‹å°±æƒ³æ¸…æ¥š edge case å°±æ¯”è¾ƒå¥½ã€‚ 12345678910111213141516171819202122class Solution(object): def dominantIndex(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 1: return 0 max_num = -1 sec_max_num = -1 max_index = 0 for i, num in enumerate(nums): if num &gt; max_num: sec_max_num = max_num max_num = num max_index = i elif num &gt; sec_max_num: sec_max_num = num if max_num &gt;= sec_max_num * 2: return max_index else: return -1]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python å¤§æˆ˜ Leetcode â€“ 696]]></title>
    <url>%2F2018%2F02%2F22%2F696%2F</url>
    <content type="text"><![CDATA[696. Count Binary Substrings ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ•°å‡ºæ‹¥æœ‰åŒæ ·å¤šä¸ªæ•°è¿žç»­çš„ 0 æˆ– 1 çš„éžç©ºå­å­—ç¬¦ä¸²æ•°ç›®ã€‚ç¬¦åˆè¦æ±‚çš„å­å­—ç¬¦ä¸²è¿˜æœ‰ä¸€ä¸ªç‰¹å¾ï¼Œå°±æ˜¯å®ƒçš„ 0 æˆ– 1 å¿…é¡»æ˜¯è¿žåœ¨ä¸€èµ·çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ 0011 æˆ– 1100 æ˜¯ç¬¦åˆè¦æ±‚çš„å­—ç¬¦ä¸²ï¼Œä½†æ˜¯ 0101 å°±ä¸æ˜¯ã€‚ç›¸åŒçš„å­å­—ç¬¦ä¸²å¦‚æžœå‡ºçŽ°å¤šæ¬¡ï¼Œé‚£æˆ‘ä»¬è¦æŠŠå‡ºçŽ°çš„æ‰€æœ‰æ¬¡æ•°éƒ½ç®—ä¸Šã€‚ ç¤ºä¾‹ 1ï¼š1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. ç¤ºä¾‹ 2ï¼š123Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&apos;s and 0&apos;s. ç¤ºä¾‹ä¸­çš„è§£é‡ŠåŸºæœ¬è·Ÿæˆ‘ä¸Šé¢è¯´çš„ä¸€æ ·ã€‚ å¦å¤–æœ‰ä¸¤ä¸ªæç¤ºï¼š s.length ä¼šåœ¨ 1 å’Œ 50,000 ä¹‹é—´ã€‚ s åªä¼šåŒ…å« â€œ0â€ æˆ– â€œ1â€ è¿™ä¸¤ä¸ªå­—ç¬¦ã€‚ ç¬¬ä¸€ä¸ªæƒ³æ³•æ˜¯è¿™é¢˜åº”è¯¥å¯ä»¥æŠŠæ—¶é—´å¤æ‚åº¦æŽ§åˆ¶åœ¨ O(n)ï¼Œn å°±æ˜¯ s.lengthã€‚ä¸€å¼€å§‹çœ‹èµ·æ¥æ¯”è¾ƒå›°éš¾çš„ä¼¼ä¹Žæ˜¯ç±»ä¼¼äºŽ â€œ000111â€ è¿™ç§æ¯”è¾ƒé•¿çš„ç¬¦åˆæ¡ä»¶çš„å­—ç¬¦ä¸²åŒ…å«äº†ä¸æ­¢ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å­å­—ç¬¦ä¸²ã€‚ä»”ç»†æƒ³ä¸€ä¸‹å…¶å®žåˆšæ‰é‚£ä¸ªåŒ…å« 3 ä¸ªç›¸åŒ â€œ0â€ å’Œ â€œ1â€ çš„å­—ç¬¦ä¸²å°±åŒ…å«äº† 3 ä¸ªç¬¦åˆè¦æ±‚çš„å­—ç¬¦ä¸²ï¼Œåˆ†åˆ«æ˜¯ â€œ000111â€ï¼Œâ€0011â€ ä»¥åŠ â€œ01â€ã€‚è¿™æ ·ä¸€æ¥å°±å¾ˆå¥½å¤„ç†äº†ï¼Œæˆ‘ä»¬åªéœ€è¦éåŽ†å­—ç¬¦ä¸²ï¼Œåœ¨è¿‡ç¨‹ä¸­æ‰¾å‡ºé‚£äº›æœ€é•¿çš„ç¬¦åˆè¦æ±‚çš„å­å­—ç¬¦ä¸²ï¼Œå†æ ¹æ®è¿™ä¸ªå­å­—ç¬¦ä¸²é‡Œé¢æœ‰å¤šå°‘ä¸ª 0ï¼ˆæˆ– 1ï¼‰æ¥ç¡®å®šå°çš„ç¬¦åˆæ¡ä»¶çš„å­å­—ç¬¦ä¸²ã€‚é‚£ä¹ˆå¦‚ä½•æ‰¾ç¬¦åˆè¦æ±‚çš„æœ€é•¿çš„å­å­—ç¬¦ä¸²å‘¢ï¼Œä¼¼ä¹Žç”¨ä»£ç æ¥è§£é‡Šæ¯”è¾ƒå¥½ã€‚ä»¥ 00110011 æ¥ä¸¾ä¾‹ï¼Œæˆ‘ä»¬ä¸€å¼€å§‹å–ç¬¬ä¸€ä¸ªå­—ç¬¦ â€˜0â€™ ä¸ºå½“å‰å­—ç¬¦ï¼Œè®°æˆ curCharï¼ŒéåŽ†çš„æ—¶å€™çœ‹æ¯ä¸ªå­—ç¬¦æ˜¯å¦å’Œå½“å‰å­—ç¬¦ç›¸åŒï¼Œå¦‚æžœç›¸åŒï¼Œæˆ‘ä»¬è®°å½•å½“å‰ç¢°åˆ°ç›¸åŒå­—ç¬¦çš„æ¬¡æ•°ï¼ŒcurLenã€‚å¦‚æžœä¸åŒï¼Œæ¯”å¦‚è¯´ç¢°åˆ°ç¬¬ä¸€ä¸ª â€˜1â€™ çš„æ—¶å€™ï¼Œå°±æŠŠ curChar è®¾æˆ â€˜1â€™ï¼Œå› ä¸ºæˆ‘ä»¬å½“å‰çš„å­—ç¬¦å·²ç»ä¸æ˜¯ â€˜0â€™ äº†ï¼Œæ‰€ä»¥æŠŠ curLen çš„å€¼è®°å½•åˆ° prevLen é‡Œé¢ï¼Œç„¶åŽ curLen æ˜¯çŽ°åœ¨ç¢°åˆ° â€˜1â€™ çš„æ¬¡æ•°ï¼Œä¹Ÿå°±1ã€‚å†æ¬¡ç¢°åˆ°å’Œ â€˜1â€™ ä¸ä¸€æ ·çš„å­—ç¬¦çš„æ—¶å€™ï¼Œè¯æ˜Žæˆ‘ä»¬å·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªç¬¦åˆè¦æ±‚çš„æœ€é•¿å­å­—ç¬¦ä¸²ã€‚è¦è®°å½•æ¬¡æ•°ã€‚ è§£é‡Šæœ‰ç‚¹å¤æ‚ï¼Œçœ‹ä»£ç ä¼šæ¸…æ¥šä¸€ç‚¹ã€‚ 123456789101112131415161718192021222324object Solution &#123; def countBinarySubstrings(s: String): Int = &#123; var prevLen = 0 var curLen = 0 var curChar = s(0) var totalCounts = 0 for (c &lt;- s) &#123; if (c == curChar) &#123; // å­—ç¬¦æ²¡æœ‰è½¬æ¢ curLen += 1 &#125; else &#123; // å­—ç¬¦è½¬æ¢äº† // å¦‚æžœå·²ç»è½¬æ¢è¿‡ä¸€æ¬¡ï¼Œé‚£ä¹ˆ prevLen å°±ä¸å†æ˜¯ 0 äº†ã€‚ if(prevLen &gt; 0) &#123; // è¿™æ—¶å€™æˆ‘ä»¬è¦è®°å½•è¿™ä¸ªæœ€å¤§å­å­—ç¬¦ä¸²åŒ…å«çš„æ‰€æœ‰æ»¡è¶³è¦æ±‚å­å­—ç¬¦ä¸² totalCounts += math.min(prevLen, curLen) &#125; prevLen = curLen curLen = 1 curChar = c &#125; &#125; // è¿™é‡Œè¦å†åŠ ä¸€æ¬¡æ˜¯å› ä¸ºæˆ‘ä»¬çš„ for å¾ªçŽ¯æ²¡æ³•è®°å½•æœ€åŽçš„é‚£ä¸ªå­å­—ç¬¦ä¸² totalCounts + math.min(prevLen, curLen) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python å¤§æˆ˜ Leetcode â€“ Leetcode 775]]></title>
    <url>%2F2018%2F02%2F18%2F775%2F</url>
    <content type="text"><![CDATA[775. Global and Local Inversions æˆ‘ä»¬æœ‰æœ‰ä¸€ä¸ªæ•°ç»„ A, A æ˜¯ [0, 1, ..., N - 1] è¿™æ ·ä¸€ä¸ªæ•°ç»„çš„ä»»æ„æŽ’åˆ—ã€‚A çš„é•¿åº¦æ˜¯ Nã€‚å°±æ˜¯è¯´ A æ˜¯ä¸€ä¸ªæ‰€æœ‰ä»Ž 0 åˆ° N - 1 è¿™ N ä¸ªæ•°å­—çš„ä»»æ„æŽ’åˆ—ä¹‹åŽç»„æˆçš„ä¸€ä¸ªæ•°ç»„ã€‚ç„¶åŽå…ˆç»™ä¸¤ä¸ªå®šä¹‰ï¼š å½“ä»»æ„ i å’Œ j æ»¡è¶³ 0 &lt;= i &lt; j &lt; N ä»¥åŠ A[i] &gt; A[j] æ—¶ï¼Œæˆ‘ä»¬ç§°å…¶ä¸ºä¸€ä¸ªå…¨å±€å€’ç½®ï¼ˆGlobal Inversionsï¼‰ã€‚ å½“ä»»æ„çš„ i æ»¡è¶³ 0 &lt;= i &lt; N ä»¥åŠ A[i] &gt; A[i+1] æ—¶ï¼Œæˆ‘ä»¬ç§°å…¶ä¸ºä¸€ä¸ªæœ¬åœ°å€’ç½® ï¼ˆLocal Inversionsï¼‰ã€‚æˆ‘ä»¬çš„å‡½æ•°éœ€è¦åˆ¤æ–­ A æ˜¯å¦æ‹¥æœ‰ç›¸åŒæ•°é‡çš„å…¨å±€å€’ç½®ä»¥åŠæœ¬åœ°å€’ç½®ï¼Œå¦‚æžœæ˜¯ï¼Œè¿”å›ž trueã€‚ ç¤ºä¾‹1ï¼š123Input: A = [1,0,2]Output: trueExplanation: There is 1 global inversion, and 1 local inversion. ç¤ºä¾‹2ï¼š123Input: A = [1,2,0]Output: falseExplanation: There are 2 global inversions, and 1 local inversion. é¢˜ä¸­æœ‰é¢å¤–çš„ä¸‰ä¸ªæ³¨æ„äº‹é¡¹ï¼š A æ˜¯ [0, 1, ..., A.length - 1] è¿™æ ·ä¸€ä¸ªæ•°ç»„çš„ä»»æ„æŽ’åˆ—ã€‚ A çš„é•¿åº¦åœ¨ [1, 5000] ä¹‹é—´ã€‚ è¿™é“é¢˜çš„è¿è¡Œæ—¶é—´é™åˆ¶è¢«ç¼©çŸ­äº†ã€‚ é¦–å…ˆç†è§£ä¸€ä¸‹é¢˜ç›®é‡Œæ‰€è°“çš„å…¨å±€å€’ç½®ä»¥åŠæœ¬åœ°å€’ç½®ã€‚å‡è®¾ [0, 1, ..., N - 1] è¿™ä¸ªæ•°ç»„æ˜¯æœ€åŽŸå§‹çš„æ­£ç¡®æŽ’åˆ—ï¼Œå› ä¸ºè¿™ä¸ªæ•°ç»„é‡Œé¢æ‰€æœ‰åŽé¢çš„æ•°éƒ½æ¯”å‰é¢çš„å¤§ï¼Œé‚£ä¹ˆåœ¨å…¶ä»–çš„å¯èƒ½çš„æŽ’åˆ—é‡Œé¢ï¼Œåªè¦æœ‰ä¸€ä¸ªåŽé¢çš„æ•°æ¯”å‰é¢çš„å°ï¼Œå°±æ˜¯ä¸€ä¸ªå…¨å±€å€’ç½®ã€‚æœ¬åœ°å€’ç½®çš„è¯æ˜¯å¯¹äºŽç›¸é‚»çš„ä¸¤ä¸ªæ•°æ¥è¯´ï¼Œåªè¦åŽé¢çš„æ•°æ¯”å‰é¢çš„å°ï¼Œå°±æ˜¯æœ¬åœ°å€’ç½®ã€‚å› æ­¤ä¸éš¾å‘çŽ°å…¶å®žæœ¬åœ°å€’ç½®ä¹Ÿæ˜¯ä¸€ä¸ªå…¨å±€å€’ç½®ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦åˆ¤æ–­æ˜¯å¦è¿™ä¸ª A é‡Œé¢æ‰€æœ‰çš„å€’ç½®éƒ½æ˜¯æœ¬åœ°å€’ç½®å³å¯ã€‚æˆ–è€…è¯´åªè¦æœ‰ä¸€ä¸ªä¸æ˜¯æœ¬åœ°å€’ç½®çš„å…¨å±€å€’ç½®ï¼Œé‚£æˆ‘ä»¬å°±è¿”å›ž falseã€‚ æ ¹æ®åˆšæ‰çš„åˆ†æžå¾ˆå®¹æ˜“æƒ³åˆ°æœ´ç´ çš„è§£æ³•ï¼Œå°±æ˜¯å¯¹äºŽæ¯ä¸€ä¸ªæ•°ç»„é‡Œçš„æ•°æ¥è¯´ï¼Œæˆ‘çœ‹ä¸€ä¸‹å®ƒåŽé¢ä¸æ˜¯ç›¸é‚»çš„ä½ç½®ä¸Šæœ‰æ²¡æœ‰æ¯”å®ƒå°çš„æ•°ï¼Œå¦‚æžœæœ‰ï¼Œå°±æ˜¯ falseã€‚å¾ˆæ˜Žæ˜¾æ—¶é—´å¤æ‚åº¦æŽ¥è¿‘ 1 åˆ° N - 1 çš„æ‰€æœ‰æ•°å­—ä¹‹å’Œï¼Œä¹Ÿå°±æ˜¯ O(n^2)ã€‚è™½ç„¶æ—¶é—´å¤æ‚åº¦å¾ˆé«˜å¾ˆæœ‰å¯èƒ½ä¸æ»¡è¶³è¿™ä¸ªé¢˜ç›®çš„è¦æ±‚ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥å½“åšå‡½æ•°å¼ç¼–ç¨‹çš„ç»ƒä¹ æ¥å®žçŽ°è¿™ä¸ªè§£æ³•ã€‚ 123456789101112131415object Solution &#123; def isIdealPermutation(A: Array[Int]): Boolean = &#123; // å› ä¸ºå¯¹äºŽæ¯ä¸ªæ•°æ¥è¯´ï¼Œæˆ‘æƒ³è¦è·Ÿå®ƒåŽé¢æ‰€æœ‰é™¤äº†ç›¸é‚»ä¹‹å¤–çš„æ•°å­—æ¯”è¾ƒï¼Œå› æ­¤æˆ‘æƒ³å¾—åˆ°å½“å‰æ•°çš„ç´¢å¼•ã€‚ // ç”±äºŽå‡½æ•°å¼çš„éåŽ†æ–¹æ³•æ¯”å¦‚ map, foreach æˆ–è€…æˆ‘ä»¬ä¸‹é¢ç”¨çš„ exists éƒ½æ˜¯ä¸å¸¦ç´¢å¼•çš„ï¼Œå› æ­¤æˆ‘ä»¬ç”¨ zipWithIndex å…ˆå°†ç´¢å¼•åŠ ä¸Šã€‚ // å¯¹äºŽ A çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼ŒzipWithIndex ä¼šè¿”å›žä¸€ä¸ª tupleï¼šï¼ˆelement, indexOfElementï¼‰ !A.zipWithIndex.exists(cur =&gt; &#123; val curVal = cur._1 // tuple é‡Œçš„ç¬¬ä¸€ä¸ªå¯¹è±¡ï¼Œå°±æ˜¯åŽŸå§‹çš„ A é‡Œé¢çš„å€¼ val curInx = cur._2 // tuple çš„ç¬¬äºŒä¸ªå¯¹è±¡ï¼Œå½“å‰çš„ç´¢å¼• // ä¸¢æŽ‰å½“å‰å…ƒç´ ä»¥åŠå’Œå®ƒç›¸é‚»çš„é‚£ä¸ªä¹‹åŽï¼Œåˆ¤æ–­åŽé¢çš„æ ‘æ˜¯å¦å­˜åœ¨æ¯”å½“å‰å…ƒç´ å°çš„ // åªè¦å­˜åœ¨è¿™æ ·çš„æƒ…å†µï¼Œæˆ‘ä»¬å°±è¿”å›ž trueï¼ŒåŒæ ·ä¸Šé¢ä¸€å±‚çš„ exists ä¹Ÿä¼šè¿”å›ž true // å¦‚æžœè¿™é‡Œçš„ç»“æžœæ˜¯ trueï¼Œé‚£ä¹ˆå¾ˆæ˜Žæ˜¾æœ€ç»ˆçš„ç»“æžœæ˜¯ false A.drop(curInx + 2).exists(_ &lt; curVal) &#125;) &#125;&#125; å‡½æ•°å¼çš„å†™æ³•çœ‹èµ·æ¥è™½ç„¶å¾ˆé…·ç‚«ï¼Œä½†æ˜¯ zipWithIndex ä¼¼ä¹Žä¹Ÿæ²¡æœ‰æ¯”ä¼ ç»Ÿçš„ for index çš„å¾ªçŽ¯ä¼˜é›…å¾ˆå¤šã€‚çœ‹äº†ä¸‹ drop æ–¹æ³•çš„å®žçŽ°ä¹‹åŽï¼Œå‘çŽ°æ—¶é—´å¤æ‚åº¦è¿˜å¾—æ›´é«˜ä¸€äº›ï¼Œå› ä¸ºå®ƒéœ€è¦éåŽ† curInx + 2 æ¬¡ä¹‹åŽæ‰è¿”å›žæ–°çš„æ•°ç»„ã€‚è¿è¡Œä¹‹åŽæžœç„¶æ˜¯æ˜¾ç¤ºè¶…æ—¶ã€‚é‚£å°±è¦æƒ³ä¸€ä¸‹å…¶ä»–çš„æ›´ä¼˜è§£æ³•äº†ã€‚ å› ä¸ºè¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„æ•°ç»„ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä¸€ä¸‹è¿™ä¸ªæ•°ç»„çš„ç‰¹æ€§ï¼Œå‡è®¾æˆ‘ä»¬åªæœ‰ 3 ä¸ªæ•°ï¼Œé¦–å…ˆå¯¹äºŽæ¯ä¸€ä¸ªæ•°æ¥è¯´ï¼Œå¦‚æžœå®ƒå°±å¤„åœ¨è‡ªå·±ç´¢å¼•æ‰€åœ¨çš„ä½ç½®ï¼Œé‚£ä¹ˆè‚¯å®šæ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œè¿™æ—¶å€™æ•°ç»„å°±æ˜¯ [0, 1, 2]ã€‚å¦‚æžœç¬¬ä¸€ä¸ªæ•°æ˜¯ 2ï¼Œé‚£ä¹ˆä¸ç®¡æ€Žä¹ˆæ ·ç¬¬ä¸‰ä¸ªæ•°ä¸€å®šå°äºŽç¬¬ä¸€ä¸ªæ•°ï¼Œå› æ­¤ä¸ç¬¦åˆè¦æ±‚ã€‚æ‰€ä»¥ç¬¬ä¸€ä¸ªæ•°åªèƒ½æ˜¯ 0 æˆ– 1ã€‚å…¶å®žæ ¹æ®è¿™é‡Œçš„åˆ†æžå·²ç»å¯ä»¥æŽ¨å¯¼å‡ºå¯¹äºŽ A ä¸­çš„æ¯ä¸€ä¸ªæ•°æ¥è¯´ï¼Œæƒ³è¦ç¬¦åˆæ¡ä»¶ï¼Œæœ€å¤šåªèƒ½åœ¨åŽŸæ¥çš„ä½ç½®ä¸Šå‘å·¦æˆ–å‘å³åç¦»ä¸€ä¸ªä½ç½®ï¼ŒåŽŸæ¥çš„ä½ç½®å°±æ˜¯è¿™ä¸ªæ•°å­—æœ¬èº«ä½œä¸ºç´¢å¼•æ‰€åœ¨çš„ä½ç½®ã€‚å› ä¸ºåç§»ä¸¤ä¸ªä½ç½®ä¹‹åŽä¸€å®šä¼šäº§ç”Ÿä¸€ä¸ªå…¨å±€å€’ç½®ã€‚ é‚£ä¹ˆå…¶å®žè§£æ³•å·²ç»å‘¼ä¹‹æ¬²å‡ºäº†ï¼š1234567// not accepted python. Time limit exceeded.object Solution &#123; def isIdealPermutation(A: Array[Int]): Boolean = &#123; // è®¡ç®—æ¯ä¸ªå€¼å’Œå½“å‰ç´¢å¼•çš„åç§»é‡ï¼Œå¦‚æžœå¤§äºŽä¸€ï¼Œå°±è¿”å›ž falseã€‚ !(A.zipWithIndex.exists(el =&gt; math.abs(el._1 - el._2) &gt; 1)) &#125;&#125; ä½†æ˜¯ä¸Šé¢çš„è§£æ³•ä¹Ÿè¶…æ—¶äº†ï¼ŒåŽ»çœ‹äº†ä¸‹ zipWithIndex çš„å®žçŽ°ä¹‹åŽå‘çŽ°è¿™ä¸ªå‡½æ•°ä¹Ÿä¼šéåŽ†ä¸€é Aï¼Œä¸ºå®ƒçš„æ¯ä¸€ä¸ªå…ƒç´ åŠ ä¸Šç´¢å¼•ã€‚æ‰€ä»¥è¿™æ¬¡éåŽ†å¯¼è‡´äº†é¢å¤–çš„è¿è¡Œæ—¶é—´ï¼Œè™½ç„¶ä»Žæ—¶é—´å¤æ‚åº¦ä¸Šæ¥è®²ï¼Œ O(2n) å’Œ O(n) å…¶å®žæ²¡ä»€ä¹ˆå·®åˆ«ã€‚ä½†æ˜¯æ˜¾ç„¶è¿™ä¸ªé¢˜ç›®çš„æé†’é‡Œç»™åˆ°çš„ä¿¡æ¯è¿˜æ˜¯æœ‰ç”¨çš„ï¼Œå®ƒçš„åˆ¤æ–­æ¡ä»¶å¯¹æ—¶é—´ååˆ†æ•æ„Ÿã€‚é‚£æˆ‘ä»¬å°±ä¸èƒ½ç”¨é‚£ä¹ˆå‡½æ•°å¼çš„å†™æ³•æ¥å†™äº†ï¼Œè¿™ä¸ªæ—¶å€™ç”¨ Java æ¥å†™çš„è¯ä¸€ä¸ªä¼ ç»Ÿçš„ For å¾ªçŽ¯å°±å¾ˆå¿«è§£å†³äº†ã€‚é‚£æˆ‘ä»¬ç”¨ python æ¥å®žçŽ°çš„è¯ï¼Œå¯ä»¥æ˜¯è¿™æ ·ï¼š123456object Solution &#123; def isIdealPermutation(A: Array[Int]): Boolean = &#123; // å…ˆæž„é€ ä¸€ä¸ªç´¢å¼•åˆ—è¡¨ï¼Œä»Ž 0 åˆ° A.size - 1 !(Range(0, A.size).exists(index =&gt; math.abs(A(index) - index) &gt; 1)) &#125;&#125; è¿™ä¸€æ¬¡ç»ˆäºŽè¿‡äº†ï¼Œä½†æ˜¯çœŸè¦è€ƒè™‘ç»†èŠ‚çš„è¯ï¼Œå…¶å®žè¿™æ ·å†™ä¼šæ¯”ç”¨ Java For å¾ªçŽ¯å¤šç”¨äº† O(n) çš„ç©ºé—´å¤æ‚åº¦ï¼ˆRange ç”Ÿæˆçš„ç´¢å¼•åˆ—è¡¨ï¼‰ã€‚å½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ª index å˜é‡å’Œ While å¾ªçŽ¯æ¥å®Œå…¨æ¨¡ä»¿ Java For å¾ªçŽ¯çš„å†™æ³•ï¼Œé‚£å°±å¯ä»¥é¿å…è¿™ä¸ªé¢å¤–ç©ºé—´å¤æ‚åº¦äº†ï¼Œä½†æ˜¯æ¯•ç«Ÿ one-liner (ä¸€è¡Œè§£å†³çš„ä»£ç ) çš„è¯±æƒ‘å¾ˆå¤§ðŸ™ˆã€‚è¿™é¢˜æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯ O(n)ï¼Œè€Œä¸”æ˜¯ä¸¥æ ¼çš„ O(n), æ—¶é—´ä¸Šé¢å¦‚æžœæ˜¯ O(2n) éƒ½ä¼šå¯¼è‡´è¶…æ—¶ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python å¤§æˆ˜ Leetcode â€“ Leetcode 687]]></title>
    <url>%2F2018%2F02%2F10%2F687%2F</url>
    <content type="text"><![CDATA[687. Longest Univalue Path é¢˜ç›®å¤§æ„æ˜¯ç»™å‡ºä¸€ä¸ªäºŒå‰æ ‘ï¼Œæˆ‘ä»¬è¦æ‰¾å‡ºæœ€é•¿çš„ä¸€æ¡è·¯å¾„ï¼Œè¯¥è·¯å¾„ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½ç›¸åŒï¼Œå¹¶è¿”å›žè¯¥è·¯å¾„çš„é•¿åº¦ï¼ˆæ‰€è°“çš„â€œæœ€é•¿ç›¸åŒå€¼è·¯å¾„â€çš„é•¿åº¦ï¼‰ã€‚ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„é•¿åº¦æŒ‡çš„æ˜¯èŠ‚ç‚¹ä¹‹é—´è¾¹çš„æ•°é‡è¿™ä¸ªé¢˜ç›®çš„å…³é”®æ˜¯ç†è§£è¿™ä¸ªâ€œæœ€é•¿ç›¸åŒå€¼è·¯å¾„â€ã€‚é¢˜ç›®ä¸­æ²¡æœ‰ç»™å‡ºè¿™ä¸ªåè¯è¯¦ç»†çš„è§£é‡Šï¼Œåªç»™äº†ä¸¤ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¾‹å­ã€‚ ç¤ºä¾‹1ï¼šInput:12345 5 / \ 4 5 / \ \1 1 5 Output:2 Input:12345 1 / \ 4 5 / \ \4 4 5 Output:2 ç¬¬ä¸€ä¸ªä¾‹å­å¯ä»¥çœ‹åˆ°æ ¹èŠ‚ç‚¹å’Œå³å­æ ‘ç»„æˆçš„3ä¸ª5æ‹¥æœ‰æœ€é•¿ç›¸åŒå€¼è·¯å¾„ï¼Œç¬¬ä¸€ä¸ª 5 å’Œæœ€åŽä¸€ä¸ª 5 ä¹‹é—´ä¸€å…±æœ‰ 2 æ¡è¾¹ï¼Œæ‰€ä»¥æ˜¯ 2ã€‚ç¬¬äºŒä¸ªä¾‹å­å·¦è¾¹çš„ 3 ä¸ª 4 æž„æˆäº†æœ€é•¿ç›¸åŒå€¼è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä»Žæœ€å·¦ä¸‹è§’çš„4å¼€å§‹ï¼Œç»è¿‡çˆ¶èŠ‚ç‚¹çš„é‚£ä¸ª 4ï¼Œåˆ°è¾¾å³è¾¹çš„ 4ï¼Œæ‰€ä»¥é•¿åº¦ä¹Ÿæ˜¯ 2ã€‚ è¿™ä¸ªæœ€é•¿ç›¸åŒå€¼è·¯å¾„çœ‹èµ·æ¥ä¼¼ä¹Žå¾ˆå®¹æ˜“å®šä¹‰ï¼Œä½†æ˜¯æˆ‘åœ¨ä¸€å¼€å§‹åšè¿™é“é¢˜çš„æ—¶å€™æ²¡æƒ³æ¸…æ¥šè¿™ä¸ªæ¦‚å¿µçš„ç¡®åˆ‡å«ä¹‰å°±å¼€å§‹å†™ä»£ç ï¼Œå¯¼è‡´èµ°äº†å¾ˆå¤šå¼¯è·¯ã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆæ¥åˆ†æžä¸€ä¸‹è¿™ä¸ªæ¦‚å¿µçš„å…·ä½“å«ä¹‰ã€‚è¿™ä¸ªæ¦‚å¿µæœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š è¿™ä¸ªè·¯å¾„ä¸æ˜¯æ— é™åˆ†å‰çš„ï¼Œä¸ç„¶å°±æž„ä¸æˆä¸€æ¡ä»Žå¤´åˆ°å°¾çš„è·¯å¾„ã€‚ ä½†æ˜¯è¿™ä¸ªè·¯å¾„å…è®¸æœ‰è‡³å¤šä¸€ä¸ªåˆ†å‰ç‚¹ï¼Œä¾‹äºŒé‡Œé¢çš„çˆ¶èŠ‚ç‚¹ 4 å°±æ˜¯ä¸€ä¸ªä¾‹å­ã€‚å½“ç„¶ä¹Ÿå¯ä»¥æ²¡æœ‰åˆ†å‰ç‚¹ï¼Œæ¯”å¦‚ä¾‹ 1ã€‚ è¿™ä¸ªæ¦‚å¿µå¯¼è‡´è·¯å¾„ä¸­çš„åˆ†å‰ç‚¹æˆäº†ä¸€ä¸ªç‰¹æ®Šçš„ç‚¹ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä»Žè¿™é‡Œåšæ–‡ç« ã€‚ åœ¨ä¸è€ƒè™‘ç»†èŠ‚å’Œå…·ä½“å®žçŽ°çš„çš„æƒ…å†µä¸‹ï¼Œæˆ‘çš„ä¸€ä¸ªå•çº¯çš„æƒ³æ³•æ˜¯éåŽ†èŠ‚ç‚¹ï¼Œæ¯æ¬¡éåŽ†çš„æ—¶å€™æ‰¾åˆ°ä»¥è¿™ä¸ªèŠ‚ç‚¹ä¸ºåˆ†å‰èŠ‚ç‚¹çš„ç›¸åŒå€¼è·¯å¾„é•¿åº¦ã€‚åŸºäºŽè¿™ä¸ªæƒ³æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªå…¨å±€å˜é‡è®°å½•è¿™ä¸ªæœ€å¤§å€¼ï¼Œç„¶åŽæ¯æ¬¡éåŽ†çš„æ—¶å€™æ¯”è¾ƒæ”¹å˜è¿™ä¸ªæœ€å¤§å€¼ã€‚ä½†æ˜¯è¿™ä¸ªæ–¹æ³•å¹¶ä¸å‡½æ•°å¼ï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨é€’å½’çš„æ–¹å¼æ¥å®žçŽ°:123456789101112def longestUnivaluePath(root: TreeNode): Int = &#123; if (root == null) &#123; 0 &#125; else &#123; // å‡è®¾ findLength ä¼šæ‰¾åˆ°ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºåˆ†å‰èŠ‚ç‚¹çš„æœ€é•¿ç›¸åŒå€¼è·¯å¾„ val nodeLen = findLength(root) // ä»¥å½“å‰èŠ‚ç‚¹ä¸ºåˆ†å‰èŠ‚ç‚¹çš„æœ€é•¿ç›¸åŒå€¼è·¯å¾„ val leftLen = longestUnivaluePath(root.left) // å·¦å­æ ‘çš„æœ€é•¿è·¯å¾„ val rightLen = longestUnivaluePath(root.right) // å³å­æ ‘çš„æœ€é•¿è·¯å¾„ // è¿”å›žä¸Šé¢ä¸‰ä¸ªå€¼ä¸­æœ€å¤§çš„é‚£ä¸ª (nodeLen :: leftLen :: rightLen :: Nil) reduce (_ max _) // æž„é€ ä¸€ä¸ª list å¹¶è¿”å›žæœ€å¤§å€¼ &#125;&#125; æ‰€ä»¥æˆ‘ä»¬çŽ°åœ¨åªè¦æŠŠ findLength è¿™ä¸ªæ–¹æ³•å®žçŽ°å°±å¯ä»¥äº†ã€‚è¿™é‡Œæ˜¯æˆ‘çº ç»“æœ€ä¹…çš„åœ°æ–¹ï¼Œé‡å†™äº†å‡ æ¬¡ï¼ŒåŽŸå› å°±æ˜¯ä¹‹å‰è¯´çš„æ²¡æœ‰æŠŠæœ€é•¿ç›¸åŒå€¼è·¯å¾„çš„å®šä¹‰æƒ³æ¸…æ¥šå°±å¼€å§‹å†™äº†ã€‚æˆ‘ä»¬å†å›žé¡¾ä¸€ä¸‹ä¸Šé¢è®²åˆ°çš„ä¸¤ä¸ªç‰¹æ€§ï¼Œæ ¹æ®é‚£ä¸¤ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥æ€»ç»“å‡º findLength æ–¹æ³•è¯¥æ€Žä¹ˆå†™ï¼š å¯¹äºŽå¯èƒ½å­˜åœ¨çš„åˆ†å‰ç‚¹è€Œè¨€ï¼Œæˆ‘ä»¬è¦åšçš„å°±æ˜¯æ‰¾åˆ°å®ƒå·¦å­æ ‘å’Œå³å­æ ‘çš„æœ€å¤§ç›¸åŒå€¼è·¯å¾„é•¿åº¦ï¼Œè¿”å›žç›¸åŠ çš„å€¼ã€‚ å¯¹äºŽä¸æ˜¯åˆ†å‰ç‚¹çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬ä¸èƒ½æŠŠå®ƒçš„å·¦å­æ ‘å’Œå³å­æ ‘çš„æœ€å¤§ç›¸åŒè·¯å¾„é•¿åº¦ç›¸åŠ ï¼Œè€Œæ˜¯è¦å¯¹æ¯”ä¸¤ä¸ªå€¼ï¼Œè¿”å›žå¤§çš„é‚£ä¸ªã€‚æ‰€ä»¥å®Œæ•´çš„ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930object Solution &#123; def longestUnivaluePath(root: TreeNode): Int = &#123; if (root == null) &#123; 0 &#125; else &#123; // å‡è®¾ findLength ä¼šæ‰¾åˆ°ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºåˆ†å‰èŠ‚ç‚¹çš„æœ€é•¿ç›¸åŒå€¼è·¯å¾„é•¿åº¦ val nodeLen = findLength(root) // ä»¥å½“å‰èŠ‚ç‚¹ä¸ºåˆ†å‰èŠ‚ç‚¹çš„æœ€é•¿ç›¸åŒå€¼è·¯å¾„é•¿åº¦ val leftLen = longestUnivaluePath(root.left) // å·¦å­æ ‘çš„æœ€é•¿è·¯å¾„ val rightLen = longestUnivaluePath(root.right) // å³å­æ ‘çš„æœ€é•¿è·¯å¾„ // è¿”å›žä¸Šé¢ä¸‰ä¸ªå€¼ä¸­æœ€å¤§çš„é‚£ä¸ª (nodeLen :: leftLen :: rightLen :: Nil) reduce (_ max _) // æž„é€ ä¸€ä¸ª list å¹¶è¿”å›žæœ€å¤§å€¼ &#125; &#125; def findLength(node: TreeNode): Int = &#123; // å¯¹åˆ†å‰èŠ‚ç‚¹æ¥è¯´ï¼Œæ‰¾åˆ°å·¦å³å­æ ‘çš„æœ€é•¿ç›¸åŒå€¼è·¯å¾„é•¿åº¦ï¼Œå¹¶è¿”å›žå’Œ findChildLength(node.left, node.value) + findChildLength(node.right, node.value) &#125; def findChildLength(child: TreeNode, rootValue: Int): Int = &#123; // å¯¹äºŽéžåˆ†å‰èŠ‚ç‚¹æ¥è¯´ï¼Œå¦‚æžœå€¼ä¸ç­‰äºŽåˆ†å‰èŠ‚ç‚¹çš„å€¼ï¼Œåˆ™è¿”å›ž0 if (child == null || child.value != rootValue) &#123; 0 &#125; else &#123; val left = findChildLength(child.left, rootValue) val right = findChildLength(child.right, rootValue) // é¦–å…ˆè¿™ä¸ªèŠ‚ç‚¹è·Ÿåˆ†å‰èŠ‚ç‚¹å€¼ç›¸åŒï¼Œå› æ­¤è¿”å›žçš„æœ€å°å€¼æ˜¯ 1 // ç„¶åŽå†åŠ ä¸Šå·¦å³å­æ ‘ä¸­æ¯”è¾ƒå¤§çš„é‚£ä¸ªç›¸åŒå€¼è·¯å¾„é•¿åº¦ 1 + (left max right) &#125; &#125;&#125; æ—¶é—´å¤æ‚åº¦æ–¹é¢ï¼Œå¯¹äºŽ longestUnivaluePath è¿™ä¸ªæ–¹æ³•æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªå…ˆåºéåŽ†ï¼Œæ‰€ä»¥å®ƒçš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œä½†æ˜¯å¯¹äºŽæ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬åˆåšäº† findLength è¿™ä¸ªæ“ä½œï¼Œè¿™ä¸ªæ“ä½œç†è®ºä¸Šæœ€åæƒ…å†µä¹Ÿä¼šå¯¹ä»Žå½“å‰èŠ‚ç‚¹å¼€å§‹çš„æ‰€æœ‰å­èŠ‚ç‚¹åšéåŽ†ã€‚ä½†æ˜¯æ€»çš„å¤æ‚åº¦ç»å¯¹ä¸æ˜¯ O($n^2$)ï¼Œå› ä¸ºå¯¹äºŽæ¯ä¸ªå­èŠ‚ç‚¹æ¥è¯´ï¼Œå®ƒæ‰€éœ€è¦éåŽ†çš„èŠ‚ç‚¹æ•°ç›®æ˜¯æˆå€ä¸‹é™çš„ï¼Œå› æ­¤æœ€å¤§çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥æ˜¯ O($n\log n$)ï¼Œç²¾ç¡®çš„å€¼åº”è¯¥æ¯”è¿™ä¸ªæ›´å°ä¸€ç‚¹ï¼Œä½†æ˜¯ä¸çŸ¥é“è¯¥æ€Žä¹ˆæ±‚ï¼Œæ¬¢è¿Žç•™è¨€è®¨è®ºã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python å¤§æˆ˜ Leetcode - Leetcode 653]]></title>
    <url>%2F2018%2F01%2F07%2F653%2F</url>
    <content type="text"><![CDATA[653. Two Sum IV - Input is a BST é¢˜ç›®å¤§æ„æ˜¯è¯´æˆ‘ä»¬æœ‰ä¸€é¢—äºŒå‰æœç´¢æ ‘ ï¼ˆBSTï¼‰ï¼Œåˆ¤æ–­æ ‘é‡Œæ˜¯å¦æœ‰ä»»æ„ä¸¤ä¸ªæ•°çš„å’Œç­‰äºŽç»™å®šçš„æ•° Kï¼Œå¦‚æžœæœ‰çš„è¯è¿”å›ž trueã€‚æ ·ä¾‹ 1ï¼š12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True æ ·ä¾‹ 2ï¼š12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False æœ€å•çº¯çš„æƒ³æ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªé›†åˆä¿å­˜æ ‘çš„èŠ‚ç‚¹å€¼ï¼ŒéåŽ†è¿™æ£µæ ‘ï¼Œæ¯ç¢°åˆ°ä¸€ä¸ªèŠ‚ç‚¹ xï¼Œå°±çœ‹ä¸€ä¸‹è¿™ä¸ªé›†åˆé‡Œæ˜¯å¦å­˜åœ¨å’Œ x ç›¸åŠ æˆä¸ºç›®æ ‡å€¼ k çš„é‚£ä¸ªå€¼ï¼Œå…·ä½“åœ°å°±æ˜¯æŸ¥çœ‹é›†åˆæ˜¯å¦å­˜åœ¨ k - x è¿™ä¸ªå€¼ã€‚è¿™ä¸ªæƒ³æ³•è¿˜æ˜¯æ¯”è¾ƒå¥½å®žçŽ°çš„ï¼š 1234567891011121314151617181920212223/** * Definition for a binary tree node. * class TreeNode(var _value: Int) &#123; * var value: Int = _value * var left: TreeNode = null * var right: TreeNode = null * &#125; */import python.collection.mutable.Set // æ³¨æ„è¿™é‡Œæˆ‘ä»¬ç”¨ mutable setobject Solution &#123; def findTarget(root: TreeNode, k: Int): Boolean = &#123; var cache = Set[Int]() findTarget(root, cache, k) &#125; private def findTarget(t: TreeNode, cache: Set[Int], k: Int): Boolean = &#123; if (t == null) return false if (cache.contains(t.value)) return true // å­˜æ”¾ cache çš„æ—¶å€™å¯ä»¥æŠŠ k - t.value å­˜è¿›åŽ» // æˆ–è€…ä¹Ÿå­˜ t.value, åœ¨ä¸Šé¢é‚£ä¸€æ­¥åŽ»æŸ¥çœ‹ cache.contains(k - t.value) cache.add(k - t.value) findTarget(t.left, cache, k) || findTarget(t.right, cache, k) &#125;&#125; ä¸Šé—¨çš„è§£æ³•æœ€å·®æƒ…å†µéåŽ†äº†æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œç„¶åŽå¯¹äºŽæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰å¯èƒ½ä¼šå ç”¨é¢å¤–çš„å­˜å‚¨ç©ºé—´ã€‚å› æ­¤æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯ O(n)ã€‚åŽæ¥ç½‘ä¸Šçœ‹åˆ°å¦ä¸€ä¸ªæ€è·¯ã€‚ç”±äºŽæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œå› æ­¤å¯¹å®ƒçš„ä¸­åºéåŽ†ç»“æžœæ˜¯ä¸ªæœ‰åºçš„é€’å¢žæ•°åˆ—ã€‚æˆ‘ä»¬å°±å¯ä»¥æŠŠè¿™ä¸ªé—®é¢˜è½¬å˜æˆä¸€ä¸ªæ•°ç»„çš„ 2-sum é—®é¢˜ã€‚å¦‚æžœæ˜¯æ”¾åœ¨æ•°ç»„ä¸Šè€Œä¸æ˜¯æ ‘ä¸Šæ¥è§£è¿™ä¸ªé—®é¢˜ï¼Œè™½ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨åŒæ ·çš„æ€è·¯ç”¨ä¸€ä¸ªé›†åˆæ¥åšï¼Œä½†æ˜¯è¿™æ ·æµªè´¹äº†é¢å¤–çš„ç©ºé—´ï¼ˆå‰ææ˜¯è¿™ä¸ªé¢˜ç›®æœ¬æ¥è¯´æ˜¯åœ¨æ•°ç»„ä¸Šè€Œä¸æ˜¯æ ‘ä¸Šï¼‰ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæ¯”è¾ƒå·§å¦™çš„åŒæŒ‡é’ˆæ–¹æ³•æ¥è§£ã€‚ä¸€å¼€å§‹ l æŒ‡é’ˆæŒ‡å‘æ•°ç»„çš„å¼€å¤´ï¼Œr æŒ‡é’ˆæŒ‡å‘æ•°ç»„çš„ç»“å°¾ã€‚è€ƒå¯Ÿ l å’Œ r ä»£è¡¨çš„å€¼çš„å’Œï¼Œå› ä¸ºæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œå› æ­¤å¦‚æžœè¿™ä¸ªå’Œæ¯” k å°ï¼Œæˆ‘ä»¬åªéœ€è¦å³ç§» l æŒ‡é’ˆï¼Œåä¹‹å·¦ç§» r æŒ‡é’ˆã€‚12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * class TreeNode(var _value: Int) &#123; * var value: Int = _value * var left: TreeNode = null * var right: TreeNode = null * &#125; */import python.collection.mutable.ArrayBufferobject Solution &#123; def findTarget(root: TreeNode, k: Int): Boolean = &#123; var li = ArrayBuffer[Int]() inorder(root, li) var l = 0 var r = li.length - 1 while(l &lt; r) &#123; // å¦‚æžœ l å’Œ r ç›¸äº¤è¿˜æ²¡æœ‰æ‰¾åˆ°ï¼Œé‚£ä¹ˆè‚¯å®šæ²¡æœ‰ var total = li(l) + li(r) if (total &lt; k) &#123; l += 1 &#125; else if (total &gt; k) &#123; r -= 1 &#125; else &#123; return true &#125; &#125; false &#125; private def inorder(t: TreeNode, li: ArrayBuffer[Int]): Unit = &#123; if (t == null) return inorder(t.left, li) li += t.value inorder(t.right, li) &#125;&#125; å¯ä»¥è¿™æ ·å†™äº†ä¹‹åŽä»£ç é•¿åº¦é•¿äº†ä¸å°‘ï¼Œå¯è¯»æ€§ä¹Ÿæ”¶åˆ°å½±å“ï¼Œè€Œä¸”æœ€é‡è¦çš„æ—¶å€™å› ä¸ºæˆ‘ä»¬è¿˜æ˜¯éœ€è¦ä¸€ä¸ª ArrayBuffer æ¥å­˜å‚¨æ ‘çš„èŠ‚ç‚¹ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦å¹¶æ²¡æœ‰é™ä½Žï¼Œè¿˜æ˜¯ O(n)ã€‚ä¸è¿‡è¿™é‡Œæˆ‘ä»¬çœ‹ä¼¼å¯¹æ•´ä¸ªæ•°æ®è¿›è¡Œäº†ä¸æ­¢ä¸€éçš„éåŽ†ï¼Œä½†æ˜¯æ•´ä¸ªæ—¶é—´å¤æ‚åº¦è¿˜æ˜¯ O(n)ï¼ŒBig O notation çš„ç‰¹ç‚¹æ˜¯çœç•¥ n å‰é¢çš„å¸¸æ•°ï¼Œæ¯”å¦‚ 2nï¼Œå› ä¸ºè¿™ä¸ªæ²¡æœ‰æ„ä¹‰ã€‚æœ‰çš„ä»£ç çœ‹èµ·æ¥åªæœ‰ä¸€æ¬¡éåŽ†ï¼Œä½†æ˜¯éåŽ†ä¸­é—´çš„é€»è¾‘å¾ˆå¤æ‚ï¼Œåšäº†å¤§é‡çš„æ“ä½œï¼Œè¿™æ ·çš„å®žé™… cpu æ—¶é—´å¯èƒ½ä¼šæ¯”ä¸¤æ¬¡ç®€å•éåŽ†çš„æ—¶é—´è¦ä¹…ã€‚ä¸è¿‡æŒ‰æˆ‘ä¹‹å‰è¯´çš„ï¼Œè¿™ä¸ªæ€è·¯åœ¨æœ¬èº«å°±æ˜¯æ•°ç»„æˆ–è€…å…¶ä»–çš„ä¸€äº›æƒ…å†µä¸‹æ˜¯ä¸ªå¾ˆå¥½çš„èŠ‚çœç©ºé—´çš„æ€è·¯ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python å¤§æˆ˜ Leetcode â€“ Leetcode 617]]></title>
    <url>%2F2018%2F01%2F04%2F617%2F</url>
    <content type="text"><![CDATA[Leetcode 617. Merge Two Binary Trees è¿™ä¸ªé¢˜ç›®è™½ç„¶æ˜¯ç®€å•é¢˜ï¼Œä½†æ˜¯æ„Ÿè§‰è¿˜æ˜¯è›®æœ‰æ„æ€çš„ã€‚é¢˜ç›®å¤§æ„æ˜¯æˆ‘ä»¬çŽ°åœ¨æœ‰ä¸¤é¢—äºŒå‰æ ‘ï¼Œç„¶åŽæˆ‘ä»¬è¦æŠŠå®ƒä»¬åˆåœ¨ä¸€èµ·ç”Ÿæˆä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ã€‚å‡è±¡ä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹ï¼Œå› ä¸ºå¹¶æ²¡æœ‰ä¿è¯ä¸¤é¢—æ ‘æ˜¯ç›¸åŒå¤§å°çš„ï¼Œæ‰€ä»¥åˆçš„æ—¶å€™ï¼Œæœ‰çš„èŠ‚ç‚¹æ˜¯é‡å çš„ï¼Œæœ‰çš„èŠ‚ç‚¹æ˜¯å•ç‹¬çš„ã€‚æˆ‘ä»¬éœ€è¦æŠŠé‡å èŠ‚ç‚¹çš„å€¼åŠ åœ¨ä¸€èµ·ï¼Œå•ç‹¬èŠ‚ç‚¹çš„å€¼å°±ä¿æŒä¸åŠ¨ã€‚ä¸‹é¢çœ‹ä¸€ä¸ªä¾‹å­ï¼š1234567891011121314Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 é¢˜ç›®ä¸­è¿˜ç‰¹æ„æŒ‡å‡ºéœ€è¦ä»Žæ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹åˆå¹¶ã€‚æˆ‘æ„Ÿè§‰è¿™å¥è¯ä¸Žå…¶è¯´æ˜¯ä¸ªé™åˆ¶è¿˜ä¸å¦‚è¯´æ˜¯ä¸ªæç¤ºï¼Œæˆ‘ä»¬çŸ¥é“äºŒå‰æ ‘ç”±äºŽå®ƒè‡ªèº«çš„ç‰¹æ€§ï¼Œå¤§éƒ¨åˆ†çš„æ“ä½œéƒ½å¯ä»¥ä½¿ç”¨é€’å½’çš„æ–¹æ³•æ¥å®žçŽ°ã€‚è¿™ä¸ªé¢˜ç›®ä¹Ÿä¸ä¾‹å¤–ã€‚æ ¹æ®ä»Žæ ¹èŠ‚ç‚¹å¼€å§‹çš„æç¤ºï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å…ˆåºéåŽ†ï¼ˆpreorder traversalï¼‰ã€‚ä¸‹é¢æ˜¯æˆ‘çš„å®žçŽ°123456789101112131415161718/** * Definition for a binary tree node. * class TreeNode(var _value: Int) &#123; * var value: Int = _value * var left: TreeNode = null * var right: TreeNode = null * &#125; */object Solution &#123; def mergeTrees(t1: TreeNode, t2: TreeNode): TreeNode = &#123; if (t1 == null) return t2 // base case if (t2 == null) return t1 // another base case val root = new TreeNode(t1.value + t2.value) // ä»Žæ ¹èŠ‚ç‚¹å¼€å§‹ root.left = mergeTrees(t1.left, t2.left) // åˆ†åˆ«çœ‹æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ root.right = mergeTrees(t1.right, t2.right) // ä»¥åŠå³å­æ ‘ root &#125;&#125; ä¸Šé¢ä»£ç ä¸­æœ‰å‡ ä¸ªå€¼å¾—æ³¨æ„çš„åœ°æ–¹ï¼š åœ¨ç¬¬ä¸€ä¸ª base case ä¸­ï¼Œt1 æ˜¯ null çš„æ—¶å€™å¦‚æžœ t2 ä¹ŸåŒæ—¶æ˜¯ nullï¼Œè¿”å›ž t2 ä¹Ÿæ˜¯æ­£ç¡®çš„ï¼Œè¡¨æ˜Žæˆ‘ä»¬æ–°çš„æ ‘ä¹Ÿåœ¨è¿™é‡Œæˆä¸ºäº†å¶å­èŠ‚ç‚¹ã€‚ ä¸¤ä¸ª base caseï¼Œè¿”å›žçš„å¿…é¡»æ˜¯ t2 æˆ–è€… t1, è€Œä¸èƒ½æ˜¯ç±»ä¼¼ new TreeNode(t1.value) è¿™æ ·çš„èŠ‚ç‚¹ï¼Œå› ä¸º t1 æˆ–è€… t2 å¯èƒ½è¿˜æœ‰å­èŠ‚ç‚¹ã€‚ è¿™ä¸ªé¢˜ç›®çš„ç²¾ç¡®æ—¶é—´å¤æ‚åº¦ä¼¼ä¹Žæœ‰ç‚¹éš¾æ±‚ï¼Œå› ä¸ºå…¶å®žæˆ‘ä»¬å¹¶æ²¡æœ‰éåŽ†ä¸¤æ£µæ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚å‡è®¾ä¸€ä¸ªæžç«¯çš„æƒ…å†µï¼Œt1 åªæœ‰å·¦å­æ ‘ï¼Œt2 åªæœ‰å³å­æ ‘ï¼Œé‚£ä¹ˆå…¶å®žæˆ‘ä»¬çš„ç®—æ³•è¿ç®—ä¸€æ¬¡å°±ç»“æŸäº†ã€‚éžè¦ç²¾ç¡®å½¢å®¹çš„è¯ï¼Œæˆ‘ä»¬å‡è®¾ä¸¤æ£µæ ‘é‡å èŠ‚ç‚¹çš„æ•°ç›®æ˜¯ K, é‚£ä¹ˆæˆ‘ä»¬çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(K)ã€‚ç©ºé—´å¤æ‚åº¦ä¹Ÿç±»ä¼¼ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰ç»™æ–°æ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹åˆ†é…å†…å­˜ç©ºé—´ï¼Œè€Œæ˜¯é‡ç”¨äº†ä¹‹å‰æ ‘ä¸­çš„èŠ‚ç‚¹ã€‚æ‰€ä»¥å­˜å‚¨æ ‘çš„ç©ºé—´å¤æ‚åº¦æ˜¯ O(K)ã€‚ä½†æ˜¯ç”±äºŽæˆ‘ä»¬ä½¿ç”¨äº†é€’å½’ï¼Œè¿˜å¿…é¡»è€ƒè™‘é€’å½’æ¯æ¬¡è°ƒç”¨å ç”¨çš„æ ˆçš„ç©ºé—´ã€‚é€’å½’è°ƒç”¨çš„æ¬¡æ•°å’Œä¸¤æ£µæ ‘é‡å éƒ¨åˆ†çš„å½¢çŠ¶æœ‰å…³ç³»ï¼Œå¦‚æžœæ˜¯ä¸€ä¸ªä¸€è¾¹å€’çš„å½¢çŠ¶ï¼ˆskewedï¼‰ï¼Œé‚£ä¹ˆæ ˆçš„æ·±åº¦æ˜¯ Kã€‚ä½†æ˜¯ä¸€èˆ¬æ¥è¯´æˆ‘ä»¬å‡è®¾æ ‘æ˜¯å·¦å³å¹³è¡¡çš„ï¼Œé‚£ä¹ˆæ·±åº¦æ˜¯ $\log_2 K$ï¼Œæœ€ç»ˆçš„ç©ºé—´å¤æ‚åº¦æ˜¯ O($\log_2 K + K$)ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python å¤§æˆ˜ Leetcode â€“ Leetcode 657]]></title>
    <url>%2F2018%2F01%2F04%2F657%2F</url>
    <content type="text"><![CDATA[Leetcode 657. Judge Route Circle é¢˜ç›®å¤§æ„æ˜¯æœ‰ä¸ªæœºå™¨äººä»Žï¼ˆ0ï¼Œ0ï¼‰ä½ç½®å‡ºå‘ï¼Œæ¯æ¬¡ä¼šä¸Šä¸‹å·¦å³é€‰ä¸€ä¸ªæ–¹å‘ç§»åŠ¨ 1 æ­¥ï¼Œæˆ‘ä»¬è¦åˆ¤æ–­å®ƒæœ€ç»ˆæ˜¯å¦å›žåˆ°åŽŸç‚¹ã€‚å®ƒçš„ç§»åŠ¨è½¨è¿¹ç”¨ä¸€ä¸ªå­—ç¬¦ä¸²æ¥æè¿°ï¼Œæ¯ä¸ªå­—ç¬¦è¡¨ç¤ºå¾€ä¸€ä¸ªæ–¹å‘ç§»åŠ¨äº†ä¸€æ­¥ï¼Œå¯èƒ½çš„å­—ç¬¦ä»¥åŠæ–¹å‘æ˜¯ï¼šL (å·¦)ï¼Œ R (å³)ï¼Œ U (ä¸Š)ï¼Œ D (ä¸‹)ã€‚ ç¤ºä¾‹1ï¼š12Input: &quot;UD&quot;Output: true ç¤ºä¾‹2ï¼š12Input: &quot;LL&quot;Output: false è¿™ä¸ªé¢˜ç›®ä¸€å¼€å§‹ç»™æˆ‘çš„æ„Ÿè§‰æ˜¯å¾ˆé€‚åˆç”¨æ ˆï¼Œä½†æ˜¯å†è½¬å¿µä¸€æƒ³å…¶å®žä¸éœ€è¦è¿™ä¹ˆéº»çƒ¦ï¼Œåªè¦ç»Ÿè®¡ä¸Šä¸‹çš„æ¬¡æ•°ä»¥åŠå·¦å³çš„æ¬¡æ•°æ˜¯å¦ç›¸åŒå°±å¯ä»¥äº†ã€‚æœ¬è´¨ä¸Šçš„æ€è·¯æ˜¯è·Ÿä½¿ç”¨æ ˆä¸€æ ·çš„ï¼Œä½†æ˜¯åœ¨è¿™ä¸ªé¢˜ç›®é‡Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨ä¸¤ä¸ªå˜é‡æ¥åˆ†åˆ«è®°å½•ä¸Šå’Œä¸‹çš„æ¬¡æ•°ä»¥åŠå·¦å’Œå³çš„æ¬¡æ•°ã€‚ä¸‹é¢æ˜¯ä»£ç ï¼š 123456789101112131415object Solution &#123; def judgeCircle(moves: String): Boolean = &#123; var vertical = 0 // è®°å½•ä¸Šä¸‹æ–¹å‘ä¸Šçš„æ­¥æ•° var horizontal = 0 // è®°å½•å·¦å³æ–¹å‘ä¸Šçš„æ­¥æ•° for (c &lt;- moves) &#123; c match &#123; case 'U' =&gt; horizontal += 1 case 'D' =&gt; horizontal -= 1 case 'L' =&gt; vertical -= 1 case 'R' =&gt; vertical += 1 &#125; &#125; horizontal == 0 &amp;&amp; vertical == 0 &#125;&#125; è¿™é‡Œå¯¹äºŽå­—ç¬¦ä¸²é‡Œé¢çš„æ¯ä¸ªå­—ç¬¦éƒ½è¿›è¡Œäº†å¤„ç†ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)ï¼Œç©ºé—´ä¸Šé¢çš„è¯å› ä¸ºåªç”¨äº†2ä¸ªå˜é‡ï¼Œæ‰€ä»¥æ˜¯ O(1)ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
</search>
