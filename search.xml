<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 747]]></title>
    <url>%2F2018%2F02%2F23%2F747%2F</url>
    <content type="text"><![CDATA[747. Largest Number At Least Twice of Others 给定一个数组 nums，这数组里面始终会有且仅有一个最大的数。我们要做的是确定这个最大的数是否比数组里的任意其他数都要大至少两倍。如果是的话，我们返回这个最大的数在数组里的索引，如果不是的话，返回 -1。 示例1：1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. 示例2：123Input: nums = [1, 2, 3, 4]Output: -1Explanation: 4 isn&apos;t at least as big as twice the value of 3, so we return -1. 注意： nums 的长度会在 [1, 50] 之间。 任意一个 nums[i] 会在 [0, 99] 之间。 这个题目很显然不难，但是有一些需要注意的地方。首先是要理清楚如何遍历数组找出最大的数以及第二大的数（如果比第二大的数大至少两倍，就一定满足题目要求）。因为这个题目给了比较多的数据上的限制，比如数组里的任何一个数都大于等于0，而且只需要记录最大以及次大的两个数，所以将题目简化了不少。我们可以使用 max_num 以及 sub_max_num 来分别记录最大及次大。因为任何数都大于等于0，因此这两个数字可以初始化成 -1, 这样就保证了他们比数组中的任何数都小，在后面的逻辑判断中不会出问题。然后找到最新的最大数之和，要记得同步地更新 sub_max_num 为之前的 max_num。细节可以看代码。123456789101112131415161718192021222324252627282930class Solution(object): def dominantIndex(self, nums): """ :type nums: List[int] :rtype: int """ # 初始化最大及次大数 max_num = -1 sub_max_num = -1 # 初始化最大数的索引 max_index = -1 # python 遍历数组小技巧，如果想要遍历的时候也同时得到元素的索引 # 可以在原始数组上使用 enumerate 函数。 # 其中 i 就是 num 对应的索引 for i, num in enumerate(nums): # 找到最大的数了 if num &gt; max_num: # 这里用到了 python 特有的 unpacking 特性。 # 正常的写法是以下的两行： # sub_max_num = max_num # max_num = num max_num, sub_max_num = num, max_num max_index = i # 找到一个次大的数 elif num &gt; sub_max_num: sub_max_num = num if max_num &gt;= sub_max_num * 2: return max_index else: return -1 很显然时间复杂度是 O(n), 空间复杂度是 O(1)。但是这个题目如果延伸一下，记录数组中前 k 个最大的数，就没那么简单了。直接给数组排序当然可以，但是首先排序的最小复杂度是 O($n\log n$)，其次是那种情况下，往往题目会要求记录一个数据流的前 k 个最大的数，也就是不方便给数组完整排序，因为数据是持续地进来的。大家可以先考虑考虑怎么做，有空碰到了类似的题目我们再讨论。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 696]]></title>
    <url>%2F2018%2F02%2F22%2F696%2F</url>
    <content type="text"><![CDATA[696. Count Binary Substrings 给定一个字符串 s，数出拥有同样多个数连续的 0 或 1 的非空子字符串数目。符合要求的子字符串还有一个特征，就是它的 0 或 1 必须是连在一起的。也就是说 0011 或 1100 是符合要求的字符串，但是 0101 就不是。相同的子字符串如果出现多次，那我们要把出现的所有次数都算上。 示例 1：1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. 示例 2：123Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&apos;s and 0&apos;s. 示例中的解释基本跟我上面说的一样。 另外有两个提示： s.length 会在 1 和 50,000 之间。 s 只会包含 “0” 或 “1” 这两个字符。 第一个想法是这题应该可以把时间复杂度控制在 O(n)，n 就是 s.length。一开始看起来比较困难的似乎是类似于 “000111” 这种比较长的符合条件的字符串包含了不止一个符合条件的子字符串。仔细想一下其实刚才那个包含 3 个相同 “0” 和 “1” 的字符串就包含了 3 个符合要求的字符串，分别是 “000111”，”0011” 以及 “01”。这样一来就很好处理了，我们只需要遍历字符串，在过程中找出那些最长的符合要求的子字符串，再根据这个子字符串里面有多少个 0（或 1）来确定小的符合条件的子字符串。那么如何找符合要求的最长的子字符串呢，似乎用代码来解释比较好。以 00110011 来举例，我们一开始取第一个字符 ‘0’ 为当前字符，记成 cur_char，遍历的时候看每个字符是否和当前字符相同，如果相同，我们记录当前碰到相同字符的次数，cur_len。如果不同，比如说碰到第一个 ‘1’ 的时候，就把 cur_char 设成 ‘1’，因为我们当前的字符已经不是 ‘0’ 了，所以把 cur_len 的值记录到 prev_len 里面，然后 cur_len 是现在碰到 ‘1’ 的次数，也就1。再次碰到和 ‘1’ 不一样的字符的时候，证明我们已经找到了一个符合要求的最长子字符串。要记录次数。 解释有点复杂，看代码会清楚一点。 1234567891011121314151617181920212223242526class Solution: def countBinarySubstrings(self, s): """ :type s: str :rtype: int """ # 这里用了 Python 的一个特性，tuple unpacking prev_len, cur_len = 0, 0 cur_char = s[0] res = 0 for c in s: # 字符没有转换，那我们把 cur_len 增加 if cur_char == c: cur_len += 1 else: # 字符转换了，且已经转换过一次，因为 prev_len 不是 0 # 代表我们已经找到一个符合条件的子字符串 # 这时我们需要统计 res if prev_len &gt; 0: res += min(cur_len, prev_len) # 转换发生的时候，现在的 cur_len 已经变成了 prev_len prev_len = cur_len cur_len = 1 cur_char = c # 最后还要加上这里是因为我们的循环没法处理最后的两个 cur_len 和 prev_len return res + min(cur_len, prev_len) 这个解法只遍历一次，时间复杂度和空间复杂度分别是 O(n) 和 O(1)。]]></content>
      <tags>
        <tag>String</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 775]]></title>
    <url>%2F2018%2F02%2F18%2F775%2F</url>
    <content type="text"><![CDATA[775. Global and Local Inversions 我们有有一个数组 A, A 是 [0, 1, ..., N - 1] 这样一个数组的任意排列。A 的长度是 N。就是说 A 是一个所有从 0 到 N - 1 这 N 个数字的任意排列之后组成的一个数组。然后先给两个定义： 当任意 i 和 j 满足 0 &lt;= i &lt; j &lt; N 以及 A[i] &gt; A[j] 时，我们称其为一个全局倒置（Global Inversions）。 当任意的 i 满足 0 &lt;= i &lt; N 以及 A[i] &gt; A[i+1] 时，我们称其为一个本地倒置 （Local Inversions）。我们的函数需要判断 A 是否拥有相同数量的全局倒置以及本地倒置，如果是，返回 true。 示例1：123Input: A = [1,0,2]Output: trueExplanation: There is 1 global inversion, and 1 local inversion. 示例2：123Input: A = [1,2,0]Output: falseExplanation: There are 2 global inversions, and 1 local inversion. 题中有额外的三个注意事项： A 是 [0, 1, ..., A.length - 1] 这样一个数组的任意排列。 A 的长度在 [1, 5000] 之间。 这道题的运行时间限制被缩短了。 首先理解一下题目里所谓的全局倒置以及本地倒置。假设 [0, 1, ..., N - 1] 这个数组是最原始的正确排列，因为这个数组里面所有后面的数都比前面的大，那么在其他的可能的排列里面，只要有一个后面的数比前面的小，就是一个全局倒置。本地倒置的话是对于相邻的两个数来说，只要后面的数比前面的小，就是本地倒置。因此不难发现其实本地倒置也是一个全局倒置，所以我们只需要判断是否这个 A 里面所有的倒置都是本地倒置即可。或者说只要有一个不是本地倒置的全局倒置，那我们就返回 false。 根据刚才的分析很容易想到朴素的解法，就是对于每一个数组里的数来说，我看一下它后面不是相邻的位置上有没有比它小的数，如果有，就是 false。很明显时间复杂度接近 1 到 N - 1 的所有数字之和，也就是 O(n^2)。虽然时间复杂度很高很有可能不满足这个题目的要求，但是我们可以当做 Python 数组操作的练习来把代码写出来。 12345678910111213class Solution: def isIdealPermutation(self, A): """ :type A: List[int] :rtype: bool """ # 用 enumerate 函数来获得数组元素的索引 i for i, num in enumerate(A): # 数组分割方法 for other_num in A[i + 2:]: if other_num &lt; num: return False return True 运行之后果然是显示超时。那就要想一下其他的更优解法了。 因为这是一个比较特殊的数组，我们可以考虑一下这个数组的特性，假设我们只有 3 个数，首先对于每一个数来说，如果它就处在自己索引所在的位置，那么肯定是没有问题的，这时候数组就是 [0, 1, 2]。如果第一个数是 2，那么不管怎么样第三个数一定小于第一个数，因此不符合要求。所以第一个数只能是 0 或 1。其实根据这里的分析已经可以推导出对于 A 中的每一个数来说，想要符合条件，最多只能在原来的位置上向左或向右偏离一个位置，原来的位置就是这个数字本身作为索引所在的位置。因为偏移两个位置之后一定会产生一个全局倒置。 那么其实解法已经呼之欲出了：12345678910class Solution: def isIdealPermutation(self, A): """ :type A: List[int] :rtype: bool """ for i, num in enumerate(A): if abs(num - i) &gt; 1: return False return True 用 Python 实现居然出奇的简单，这题时间复杂度和空间复杂度是 O(n) 和 O(1)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 687]]></title>
    <url>%2F2018%2F02%2F10%2F687%2F</url>
    <content type="text"><![CDATA[687. Longest Univalue Path 题目大意是给出一个二叉树，我们要找出最长的一条路径，该路径中所有节点的值都相同，并返回该路径的长度（所谓的“最长相同值路径”的长度）。两个节点之间的长度指的是节点之间边的数量这个题目的关键是理解这个“最长相同值路径”。题目中没有给出这个名词详细的解释，只给了两个例子，我们先看例子。 示例1：Input:12345 5 / \ 4 5 / \ \1 1 5 Output:2 Input:12345 1 / \ 4 5 / \ \4 4 5 Output:2 第一个例子可以看到根节点和右子树组成的3个5拥有最长相同值路径，第一个 5 和最后一个 5 之间一共有 2 条边，所以是 2。第二个例子左边的 3 个 4 构成了最长相同值路径，这条路径从最左下角的4开始，经过父节点的那个 4，到达右边的 4，所以长度也是 2。 这虽然是道 Easy 等级的题目，但是它的通过率比很多 Medium 要低的多…. 这个最长相同值路径看起来似乎很容易定义，但是我在一开始做这道题的时候没想清楚这个概念的确切含义就开始写代码，导致走了很多弯路。所以我们先来分析一下这个概念的具体含义。这个概念有以下特性： 这个路径不是无限分叉的，不然就构不成一条从头到尾的路径。 但是这个路径允许有至多一个分叉点（或者说连接两条不同方向的路径的点，我在代码里把它称为 joint），例二里面的父节点 4 就是一个例子。当然也可以没有分叉点，比如例 1。 这个概念导致路径中的分叉点成了一个特殊的点，因此我们可以从这里做文章。 在不考虑细节和具体实现的的情况下，我的一个单纯的想法是遍历节点，每次遍历的时候找到以这个节点为分叉节点的相同值路径长度。基于这个想法，我们可以用一个全局变量记录这个最大值，然后每次遍历的时候比较改变这个最大值。但是换个角度想，我们可以让递归遍历的方法直接返回最大值，这么想来用递归似乎更简单一点，而且可以避免全局变量就应该尽量避免： 1234567891011121314def longestUnivaluePath(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 # 找到以当前节点为分叉点的路径长度 nodeLen = self.find_length_of_joint(root) # 递归地去找当前节点的左子树及右子树 leftLen = self.longestUnivaluePath(root.left) rightLen = self.longestUnivaluePath(root.right) # 返回最大的那个 return max(nodeLen, leftLen, rightLen) 所以我们现在只要把 find_length_of_joint 这个方法实现就可以了。这里是我纠结最久的地方，重写了几次，原因就是之前说的没有把最长相同值路径的定义想清楚就开始写了。我们再回顾一下上面讲到的两个特性，根据那两个特性，我们可以总结出 find_length_of_joint 方法该怎么写： 对于可能存在的分叉点而言，我们要做的就是找到它左子树和右子树的最大相同值路径长度，返回相加的值。 对于不是分叉点的节点，我们不能把它的左子树和右子树的最大相同路径长度相加，而是要对比两个值，返回大的那个。所以完整的代码如下：123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def longestUnivaluePath(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 # 找到以当前节点为分叉点的路径长度 nodeLen = self.find_length_of_joint(root) # 递归地去找当前节点的左子树及右子树 leftLen = self.longestUnivaluePath(root.left) rightLen = self.longestUnivaluePath(root.right) # 返回最大的那个 return max(nodeLen, leftLen, rightLen) def find_length_of_joint(self, node): return self.find_length(node.left, node.val) + \ self.find_length(node.right, node.val) def find_length(self, node, joint_value): if not node or node.val != joint_value: return 0 return 1 + max(self.find_length(node.left, joint_value), self.find_length(node.right, joint_value)) 这里顺便提一下 Python 里面很长的行应该怎么分行。一种方法是使用 \（backslash），如果有操作符的话，比较推荐的方式是在操作符之后使用反斜杠，如代码中的 24 行。还有一种方式是利用 Python 自带的特性，在 ()、[] 和 {} 内换行，如 29 行。换行之后的缩进似乎不是很强制，我喜欢把它缩到跟上一行同样语义的地方。 引用下 PEP8： The preferred way of wrapping long lines is by using Python’s implied line continuation inside parentheses, brackets and braces. If necessary, you can add an extra pair of parentheses around an expression, but sometimes using a backslash looks better. Make sure to indent the continued line appropriately. The preferred place to break around a binary operator is after the operator, not before it. 时间复杂度方面，对于 longestUnivaluePath 这个方法来说，这是一个先序遍历，所以它的时间复杂度是 O(n)，但是对于每一个节点，我们又做了 find_length_of_joint 这个操作，这个操作理论上最坏情况也会对从当前节点开始的所有子节点做遍历。但是总的复杂度绝对不是 O($n^2$)，因为对于每个子节点来说，它所需要遍历的节点数目是成倍下降的，因此最大的时间复杂度应该是 O($n\log n$)，精确的值应该比这个更小一点，但是不知道该怎么求，欢迎留言讨论。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Recursion</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode - Leetcode 653]]></title>
    <url>%2F2018%2F01%2F07%2F653%2F</url>
    <content type="text"><![CDATA[653. Two Sum IV - Input is a BST 题目大意是说我们有一颗二叉搜索树 （BST），判断树里是否有任意两个数的和等于给定的数 K，如果有的话返回 true。样例 1：12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True 样例 2：12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False 最单纯的想法是使用一个集合保存树的节点值，遍历这棵树，每碰到一个节点 x，就看一下这个集合里是否存在和 x 相加成为目标值 k 的那个值，具体地就是查看集合是否存在 k - x 这个值。这个想法还是比较好实现的： 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ cache = set() return self.findHelder(cache, root, k) def findHelder(self, cache, root, k): # base case if not root: return False # 找到了我们的值 if (k - root.val) in cache: return True cache.add(root.val) return self.findHelder(cache, root.left, k) or self.findHelder(cache, root.right, k) 上门的解法最差情况遍历了树的所有节点，然后对于每个节点都有可能会占用额外的存储空间。因此时间和空间复杂度都是 O(n)。后来网上看到另一个思路。由于是二叉搜索树，因此对它的中序遍历结果是个有序的递增数列。我们就可以把这个问题转变成一个数组的 2-sum 问题。如果是放在数组上而不是树上来解这个问题，虽然也可以使用同样的思路用一个集合来做，但是这样浪费了额外的空间（前提是这个题目本来说是在数组上而不是树上）。我们可以用一个比较巧妙的双指针方法来解。一开始 l 指针指向数组的开头，r 指针指向数组的结尾。考察 l 和 r 代表的值的和，因为数组是有序的，因此如果这个和比 k 小，我们只需要右移 l 指针，反之左移 r 指针。1234567891011121314151617181920212223242526272829303132333435363738# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ li = [] # 中序遍历二叉搜索树，得到递增数列 li self.in_order(root, li) # l 从 0 开始，r 从最后开始 l = 0 r = len(li) - 1 # 如果 l == r, 证明数组所有数字已经处理完 while(l &lt; r): cur_sum = li[l] + li[r] if cur_sum &lt; k: l += 1 elif cur_sum &gt; k: r -= 1 else: return True # 如果在 while 循环里没有 return True，表明没有找到 return False # 中序遍历，对 node 的操作在遍历左节点之后。 def in_order(self, node, li): if not node: return self.in_order(node.left, li) li.append(node.val) self.in_order(node.right, li) 可以这样写了之后代码长度长了不少，可读性也收到影响，而且最重要的时候因为我们还是需要一个 ArrayBuffer 来存储树的节点，因此空间复杂度并没有降低，还是 O(n)。不过这里我们看似对整个数据进行了不止一遍的遍历，但是整个时间复杂度还是 O(n)，Big O notation 的特点是省略 n 前面的常数，比如 2n，因为这个没有意义。有的代码看起来只有一次遍历，但是遍历中间的逻辑很复杂，做了大量的操作，这样的实际 cpu 时间可能会比两次简单遍历的时间要久。不过按我之前说的，这个思路在本身就是数组或者其他的一些情况下是个很好的节省空间的思路。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 617]]></title>
    <url>%2F2018%2F01%2F04%2F617%2F</url>
    <content type="text"><![CDATA[Leetcode 617. Merge Two Binary Trees 这个题目虽然是简单题，但是感觉还是蛮有意思的。题目大意是我们现在有两颗二叉树，然后我们要把它们合在一起生成一个新的二叉树。假象一下这个过程，因为并没有保证两颗树是相同大小的，所以合的时候，有的节点是重叠的，有的节点是单独的。我们需要把重叠节点的值加在一起，单独节点的值就保持不动。下面看一个例子：1234567891011121314Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 题目中还特意指出需要从树的根节点开始合并。我感觉这句话与其说是个限制还不如说是个提示，我们知道二叉树由于它自身的特性，大部分的操作都可以使用递归的方法来实现。这个题目也不例外。根据从根节点开始的提示，我们可以使用先序遍历（preorder traversal）。下面是我的实现123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def mergeTrees(self, t1, t2): """ :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode """ # 两个 base case if not t1: return t2 if not t2: return t1 merged = TreeNode(t1.val + t2.val) # 递归地计算左子树以及右子树 merged.left = self.mergeTrees(t1.left, t2.left) merged.right = self.mergeTrees(t1.right, t2.right) return merged 上面代码中有几个值得注意的地方： 在第一个 base case 中，t1 是 None 的时候如果 t2 也同时是 None 的话，返回 t2 也是正确的，表明我们新的树也在这里成为了叶子节点。 两个 base case，返回的必须是 t2 或者 t1, 而不能是类似 TreeNode(t1.val) 这样的节点，因为 t1 或者 t2 可能还有子节点。 这个题目的精确时间复杂度似乎有点难求，因为其实我们并没有遍历两棵树的所有节点。假设一个极端的情况，t1 只有左子树，t2 只有右子树，那么其实我们的算法运算一次就结束了。非要精确形容的话，我们假设两棵树重叠节点的数目是 K, 那么我们的时间复杂度是 O(K)。空间复杂度也类似，我们并没有给新树上的每个节点分配内存空间，而是重用了之前树中的节点。所以存储树的空间复杂度是 O(K)。但是由于我们使用了递归，还必须考虑递归每次调用占用的栈的空间。递归调用的次数和两棵树重叠部分的形状有关系，如果是一个一边倒的形状（skewed），那么栈的深度是 K。但是一般来说我们假设树是左右平衡的，那么深度是 $\log_2 K$，最终的空间复杂度是 O($\log_2 K + K$)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 大战 Leetcode – Leetcode 657]]></title>
    <url>%2F2018%2F01%2F04%2F657%2F</url>
    <content type="text"><![CDATA[Leetcode 657. Judge Route Circle 题目大意是有个机器人从（0，0）位置出发，每次会上下左右选一个方向移动 1 步，我们要判断它最终是否回到原点。它的移动轨迹用一个字符串来描述，每个字符表示往一个方向移动了一步，可能的字符以及方向是：L (左)， R (右)， U (上)， D (下)。 示例1：12Input: &quot;UD&quot;Output: true 示例2：12Input: &quot;LL&quot;Output: false 这个题目比较简单，可以用来当练手和掌握 Python 的字符串遍历方法。只要统计上下的次数以及左右的次数是否相同就可以了。我们使用两个变量 vertical 和 horizontal 来分别统计上下和左右的次数。上和下分别对 vertical 进行加一和减一，左右也类似，最后只要看这两个变量是否都是 0 就行了。下面是代码： 12345678910111213141516171819class Solution: def judgeCircle(self, moves): """ :type moves: str :rtype: bool """ vertical = 0 horizontal = 0 # 遍历字符串，得到每个字符 c for c in moves: if c == 'U': vertical += 1 elif c == 'D': vertical -= 1 elif c == 'L': horizontal -= 1 elif c == 'R': horizontal += 1 return vertical == 0 and horizontal == 0 这里对于字符串里面的每个字符都进行了处理，所以时间复杂度是 O(N)，空间上面的话因为只用了2个变量，所以是 O(1)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
</search>
